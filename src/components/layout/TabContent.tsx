import { useState, useMemo, useEffect, useRef, useCallback, useLayoutEffect } from "react";
import { createPortal } from "react-dom";
import {
  DndContext,
  DragOverlay,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
  type DragStartEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  useSortable,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import {
  Plus,
  Trash2,
  ChevronDown,
  ChevronRight,
  Key,
  Table,
  Code,
  AlertCircle,
  Loader2,
  GripVertical,
  CheckCircle,
  CheckCircle2,
  XCircle,
  Copy,
  Check,
  Search,
  Link,
  Play,
  Rocket,
  Settings,
  Undo2,
  Redo2,
  Zap,
} from "lucide-react";
import { invoke } from "@tauri-apps/api/core";
import { useUIStore } from "../../stores/uiStore";
import { useProjectStore } from "../../stores/projectStore";
import { useChangesStore } from "../../stores/changesStore";
import { useTableData, useCommitChanges, useMigration, useTableColumns, getCurrentConnectionId, type MigrationResult, type FullColumnInfo } from "../../hooks/useDatabase";
import { TableView } from "../table/TableView";
import { RowDetailModal } from "../table/RowDetailModal";
import {
  Checkbox,
  CodeBlock,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Toggle,
} from "../ui";
import { generateUpdateSQL, generateDeleteSQL, generateInsertSQL, generateCreateTableSQL, generateAlterTableSQL, type ColumnDefinition, type AlterColumnDef } from "../../lib/sql";
import { cn } from "../../lib/utils";
import { ImportDataTab } from "../tabs/ImportDataTab";
import { QueryTab } from "../tabs/QueryTab";
import type { CellValue, Row, Column, Tab, SortColumn } from "../../types";

const EMPTY_SORTS: SortColumn[] = [];

/**
 * Compare two cell values for equality
 */
function valuesEqual(a: CellValue, b: CellValue): boolean {
  if (a === b) return true;
  if (a === null || b === null) return a === b;

  // Handle objects (JSONB columns)
  if (typeof a === "object" && typeof b === "object") {
    return JSON.stringify(a) === JSON.stringify(b);
  }
  // Handle case where one is string representation of the other
  if (typeof a === "object" && typeof b === "string") {
    return JSON.stringify(a) === b;
  }
  if (typeof a === "string" && typeof b === "object") {
    return a === JSON.stringify(b);
  }

  // For primitives, compare as strings to handle type coercion
  return String(a) === String(b);
}

/**
 * Check if a column value is auto-generated by the database
 */
function isAutoGeneratedColumn(col: Column): boolean {
  const type = col.dataType.toLowerCase();
  const defaultVal = col.defaultValue ?? "";
  // Auto-generated if:
  // - Serial types (serial, bigserial, smallserial)
  // - Has a function call as default (contains parentheses): nextval(), uuid_generate_v7(), gen_random_uuid(), now(), etc.
  return type.includes("serial") || /\w+\s*\(/.test(defaultVal);
}

/**
 * Renders the content for a single table tab
 */
function TableTabContent({ schema, table }: { schema: string; table: string }) {
  const tableKey = `${schema}.${table}`;
  const [page, setPage] = useState(1);
  const activeProject = useProjectStore((state) => state.getActiveProject());
  const readOnly = activeProject?.settings.readOnly ?? false;
  const instantCommit = activeProject?.settings.instantCommit ?? false;
  const openDeleteTableModal = useUIStore((state) => state.openDeleteTableModal);
  const openTruncateTableModal = useUIStore((state) => state.openTruncateTableModal);
  const addImportDataTab = useUIStore((state) => state.addImportDataTab);
  const sorts = useUIStore((state) => state.tableSortState[tableKey] ?? EMPTY_SORTS);
  const setTableSort = useUIStore((state) => state.setTableSort);
  const schemas = useProjectStore((state) => state.schemas);

  // Get row count for the current table
  const tableRowCount = useMemo(() => {
    const schemaObj = schemas.find((s) => s.name === schema);
    const tableObj = schemaObj?.tables.find((t) => t.name === table);
    return tableObj?.rowCount ?? 0;
  }, [schemas, schema, table]);

  const { data, isLoading, isFetching, error, refetch } = useTableData(
    schema, table, page, sorts,
  );
  const commitChanges = useCommitChanges();
  const addChange = useChangesStore((state) => state.addChange);
  const removeChange = useChangesStore((state) => state.removeChange);
  const allChanges = useChangesStore((state) => state.changes);

  // Row detail modal state
  const [viewingRowIndex, setViewingRowIndex] = useState<number | null>(null);
  const [isAddingRow, setIsAddingRow] = useState(false);
  const [addRowError, setAddRowError] = useState<string | null>(null);

  // Filter changes for this table - do this in useMemo to avoid infinite re-renders
  const changes = useMemo(() =>
    allChanges.filter((c) => c.schema === schema && c.table === table),
    [allChanges, schema, table]
  );

  // Track previous changes count to detect commits
  const prevChangesCount = useRef(changes.length);

  // Clear local edits when staged changes are committed (changes go from >0 to 0)
  useEffect(() => {
    if (prevChangesCount.current > 0 && changes.length === 0) {
      // Changes were cleared (commit happened), clear local edits and refetch
      setLocalEdits(new Map());
      refetch();
    }
    prevChangesCount.current = changes.length;
  }, [changes.length, refetch]);

  // Track local edits (before they're committed)
  const [localEdits, setLocalEdits] = useState<Map<string, CellValue>>(new Map());

  // Merge fetched data with local edits AND staged changes
  const mergedData = useMemo(() => {
    if (!data) return null;

    const mergedRows = data.rows.map((row, rowIndex) => {
      const mergedRow = { ...row };

      // First apply staged changes (for values that persist across tab switches)
      changes.forEach((change) => {
        if (change.type === "update" && change.originalData) {
          // Check if this change applies to this row by matching original data
          const isMatch = Object.entries(change.originalData).every(
            ([key, val]) => row[key] === val
          );
          if (isMatch) {
            Object.entries(change.data).forEach(([colName, value]) => {
              mergedRow[colName] = value;
            });
          }
        }
      });

      // Then apply local edits (for immediate feedback on current session)
      localEdits.forEach((value, key) => {
        const [editRowIndex, colName] = key.split(":");
        if (parseInt(editRowIndex) === rowIndex) {
          mergedRow[colName] = value;
        }
      });

      return mergedRow;
    });

    return {
      ...data,
      rows: mergedRows,
    };
  }, [data, localEdits, changes]);

  const handlePageChange = (newPage: number) => {
    setPage(newPage);
    // Clear local edits when changing page
    setLocalEdits(new Map());
  };

  const handleSort = useCallback((columnName: string, addToSort: boolean) => {
    const existingIndex = sorts.findIndex((s) => s.column === columnName);
    const existing = existingIndex !== -1 ? sorts[existingIndex] : null;

    let newSorts: { column: string; direction: "ASC" | "DESC" }[];

    if (addToSort) {
      // Shift+click: multi-column sort
      if (!existing) {
        // Add column to sort list
        newSorts = [...sorts, { column: columnName, direction: "ASC" }];
      } else if (existing.direction === "ASC") {
        // Cycle to DESC (keep position)
        newSorts = sorts.map((s, i) =>
          i === existingIndex ? { ...s, direction: "DESC" as const } : s
        );
      } else {
        // Remove from sort list
        newSorts = sorts.filter((_, i) => i !== existingIndex);
      }
    } else {
      // Regular click: single-column sort (replaces all)
      if (!existing) {
        newSorts = [{ column: columnName, direction: "ASC" }];
      } else if (existing.direction === "ASC") {
        newSorts = [{ column: columnName, direction: "DESC" }];
      } else {
        newSorts = [];
      }
    }

    setTableSort(tableKey, newSorts);
    setPage(1);
    setLocalEdits(new Map());
  }, [sorts, tableKey, setTableSort]);

  const handleSortsChange = useCallback((newSorts: SortColumn[]) => {
    setTableSort(tableKey, newSorts);
    setPage(1);
    setLocalEdits(new Map());
  }, [tableKey, setTableSort]);

  const handleCellEdit = useCallback((rowIndex: number, columnName: string, newValue: CellValue) => {
    if (!data) return;

    const originalRow = data.rows[rowIndex];
    const originalValue = originalRow[columnName];
    const columns = data.columns;
    const editKey = `${rowIndex}:${columnName}`;

    // Check if the new value equals the original database value
    if (valuesEqual(newValue, originalValue)) {
      // Value reverted to original - remove local edit and staged change
      setLocalEdits((prev) => {
        const next = new Map(prev);
        next.delete(editKey);
        return next;
      });

      // Find and remove any staged change for this cell
      const existingChange = allChanges.find(
        (c) =>
          c.type === "update" &&
          c.schema === schema &&
          c.table === table &&
          c.originalData &&
          Object.entries(c.originalData).every(([key, val]) => originalRow[key] === val) &&
          columnName in c.data
      );

      if (existingChange) {
        // Check if this is the only column in the change
        const changeColumns = Object.keys(existingChange.data);
        if (changeColumns.length === 1 && changeColumns[0] === columnName) {
          // Remove the entire change
          removeChange(existingChange.id);
        } else {
          // Multiple columns - need to update the change to remove just this column
          // For now, we remove the entire change (user will need to re-edit other columns)
          // This is a simplification; a more complete solution would update the change in place
          removeChange(existingChange.id);
        }
      }
      return;
    }

    // Value is different from original - stage the change
    setLocalEdits((prev) => {
      const next = new Map(prev);
      next.set(editKey, newValue);
      return next;
    });

    // Create the updated row data
    const updatedData: Row = { [columnName]: newValue };

    // Generate SQL for this change
    const sql = generateUpdateSQL(schema, table, updatedData, originalRow, columns);

    // Stage the change
    addChange({
      type: "update",
      schema,
      table,
      data: updatedData,
      originalData: originalRow,
      sql,
    });

    // TODO: If instantCommit is enabled, execute immediately
    if (instantCommit) {
      console.log("Instant commit enabled - would execute:", sql);
    }
  }, [data, schema, table, allChanges, addChange, removeChange, instantCommit]);

  // Handle row view/edit
  const handleRowView = (rowIndex: number) => {
    setViewingRowIndex(rowIndex);
  };

  // Handle row delete (stage)
  const handleRowDelete = (rowIndex: number) => {
    if (!data) return;

    const originalRow = data.rows[rowIndex];
    const columns = data.columns;

    // Generate DELETE SQL
    const sql = generateDeleteSQL(schema, table, originalRow, columns);

    // Stage the delete change
    addChange({
      type: "delete",
      schema,
      table,
      data: originalRow,
      originalData: originalRow,
      sql,
    });
  };

  // Handle multiple rows delete (stage)
  const handleRowsDelete = (rowIndices: number[]) => {
    if (!data) return;

    const columns = data.columns;

    // Stage delete changes for each row
    rowIndices.forEach((rowIndex) => {
      const originalRow = data.rows[rowIndex];
      const sql = generateDeleteSQL(schema, table, originalRow, columns);

      addChange({
        type: "delete",
        schema,
        table,
        data: originalRow,
        originalData: originalRow,
        sql,
      });
    });
  };

  // Handle direct save from row detail modal
  const handleRowSave = async (updatedRow: Row) => {
    if (!data || viewingRowIndex === null) return;

    const originalRow = data.rows[viewingRowIndex];
    const columns = data.columns;

    // Find changed columns
    const changedData: Row = {};
    Object.keys(updatedRow).forEach((key) => {
      if (updatedRow[key] !== originalRow[key]) {
        changedData[key] = updatedRow[key];
      }
    });

    if (Object.keys(changedData).length === 0) return;

    // Generate SQL
    const sql = generateUpdateSQL(schema, table, changedData, originalRow, columns);

    // Direct save - execute immediately
    try {
      await commitChanges.mutateAsync([sql]);
      refetch();
    } catch (err) {
      console.error("Failed to save:", err);
    }
  };

  // Handle stage from row detail modal
  const handleRowStage = (updatedRow: Row) => {
    if (!data || viewingRowIndex === null) return;

    const originalRow = data.rows[viewingRowIndex];
    const columns = data.columns;

    // Find changed columns
    const changedData: Row = {};
    Object.keys(updatedRow).forEach((key) => {
      if (updatedRow[key] !== originalRow[key]) {
        changedData[key] = updatedRow[key];
      }
    });

    if (Object.keys(changedData).length === 0) return;

    // Update local edits for visual feedback
    Object.entries(changedData).forEach(([colName, value]) => {
      const editKey = `${viewingRowIndex}:${colName}`;
      setLocalEdits((prev) => {
        const next = new Map(prev);
        next.set(editKey, value);
        return next;
      });
    });

    // Generate SQL and stage
    const sql = generateUpdateSQL(schema, table, changedData, originalRow, columns);
    addChange({
      type: "update",
      schema,
      table,
      data: changedData,
      originalData: originalRow,
      sql,
    });
  };

  // Handle delete from row detail modal
  const handleRowDeleteFromModal = () => {
    if (viewingRowIndex !== null) {
      handleRowDelete(viewingRowIndex);
    }
  };

  // Handle add row button click
  const handleAddRowClick = () => {
    setIsAddingRow(true);
  };

  // Handle direct save for new row
  const handleNewRowSave = async (newRow: Row) => {
    if (!data) return;

    // Filter out empty values for auto-generated columns
    const filteredRow: Row = {};
    data.columns.forEach((col) => {
      const value = newRow[col.name];
      // Skip null/undefined/empty for auto-generated columns - let DB generate
      if (isAutoGeneratedColumn(col) && (value === null || value === undefined || value === "")) {
        return;
      }
      filteredRow[col.name] = value;
    });

    // Generate INSERT SQL
    const sql = generateInsertSQL(schema, table, filteredRow, data.columns);

    // Direct save - execute immediately
    try {
      await commitChanges.mutateAsync([sql]);
      setAddRowError(null);
      setIsAddingRow(false);
      refetch();
    } catch (err) {
      // Keep modal open and show error
      let errorMessage: string;
      if (err instanceof Error) {
        errorMessage = err.message;
      } else if (typeof err === "object" && err !== null) {
        // Handle Tauri error objects which may have message or error properties
        const errObj = err as Record<string, unknown>;
        errorMessage = (errObj.message ?? errObj.error ?? JSON.stringify(err)) as string;
      } else {
        errorMessage = String(err);
      }
      setAddRowError(errorMessage);
    }
  };

  // Handle stage for new row
  const handleNewRowStage = (newRow: Row) => {
    if (!data) return;

    // Filter out empty values for auto-generated columns
    const filteredRow: Row = {};
    data.columns.forEach((col) => {
      const value = newRow[col.name];
      // Skip null/undefined/empty for auto-generated columns - let DB generate
      if (isAutoGeneratedColumn(col) && (value === null || value === undefined || value === "")) {
        return;
      }
      filteredRow[col.name] = value;
    });

    // Generate INSERT SQL
    const sql = generateInsertSQL(schema, table, filteredRow, data.columns);

    // Stage the insert
    addChange({
      type: "insert",
      schema,
      table,
      data: filteredRow,
      sql,
    });

    setIsAddingRow(false);
  };

  // Build set of edited cells for visual indication
  const editedCells = useMemo(() => {
    const edited = new Set<string>();
    localEdits.forEach((_, key) => {
      edited.add(key);
    });
    // Also mark cells from staged changes
    changes.forEach((change) => {
      if (change.type === "update" && change.originalData) {
        // Find the row index by matching original data
        const rowIndex = data?.rows.findIndex((row) => {
          // Match by primary key or first few columns
          return Object.entries(change.originalData || {}).every(
            ([key, val]) => row[key] === val
          );
        });
        if (rowIndex !== undefined && rowIndex >= 0) {
          Object.keys(change.data).forEach((colName) => {
            edited.add(`${rowIndex}:${colName}`);
          });
        }
      }
    });
    return edited;
  }, [localEdits, changes, data]);

  // Build set of deleted row indices
  const deletedRows = useMemo(() => {
    const deleted = new Set<number>();
    changes.forEach((change) => {
      if (change.type === "delete" && change.originalData) {
        // Find the row index by matching original data
        const rowIndex = data?.rows.findIndex((row) => {
          return Object.entries(change.originalData || {}).every(
            ([key, val]) => row[key] === val
          );
        });
        if (rowIndex !== undefined && rowIndex >= 0) {
          deleted.add(rowIndex);
        }
      }
    });
    return deleted;
  }, [changes, data]);

  const handleRefresh = () => {
    setLocalEdits(new Map());
    refetch();
  };

  // Handle delete table
  const handleDeleteTable = () => {
    const rowCount = data?.totalRows;
    openDeleteTableModal(schema, table, rowCount);
  };

  // Get the row data for the modal
  const viewingRow = viewingRowIndex !== null && mergedData?.rows[viewingRowIndex]
    ? mergedData.rows[viewingRowIndex]
    : null;

  const isViewingRowDeleted = viewingRowIndex !== null && deletedRows.has(viewingRowIndex);

  return (
    <>
      <TableView
        tableKey={tableKey}
        schemaName={schema}
        tableName={table}
        data={mergedData}
        isLoading={isLoading}
        isFetching={isFetching}
        error={error ? (error instanceof Error ? error.message : String(error)) : null}
        onPageChange={handlePageChange}
        onCellEdit={handleCellEdit}
        onRowView={handleRowView}
        onRowDelete={handleRowDelete}
        onRowsDelete={handleRowsDelete}
        onRefresh={handleRefresh}
        onAddRow={handleAddRowClick}
        onDeleteTable={handleDeleteTable}
        onImportCSV={() => addImportDataTab(schema, table, "csv")}
        onImportJSON={() => addImportDataTab(schema, table, "json")}
        onTruncateTable={() => openTruncateTableModal(schema, table, tableRowCount)}
        editedCells={editedCells}
        deletedRows={deletedRows}
        readOnly={readOnly}
        sorts={sorts}
        onSort={handleSort}
        onSortsChange={handleSortsChange}
      />

      {/* Row detail modal */}
      {viewingRow && data && (
        <RowDetailModal
          row={viewingRow}
          rowIndex={viewingRowIndex!}
          columns={data.columns}
          isOpen={viewingRowIndex !== null}
          onClose={() => setViewingRowIndex(null)}
          onSave={handleRowSave}
          onStage={handleRowStage}
          onDelete={handleRowDeleteFromModal}
          readOnly={readOnly}
          isDeleted={isViewingRowDeleted}
        />
      )}

      {/* Add row modal */}
      {isAddingRow && data && (
        <RowDetailModal
          columns={data.columns}
          isOpen={isAddingRow}
          onClose={() => {
            setIsAddingRow(false);
            setAddRowError(null);
          }}
          onSave={handleNewRowSave}
          onStage={handleNewRowStage}
          mode="create"
          error={addRowError}
          onClearError={() => setAddRowError(null)}
        />
      )}
    </>
  );
}

// ============================================================================
// Create Table Tab Content
// ============================================================================

// Common PostgreSQL data types organized by category
const POSTGRES_TYPES = {
  "Numeric": [
    { value: "INTEGER", label: "INTEGER", description: "Signed 4-byte integer" },
    { value: "BIGINT", label: "BIGINT", description: "Signed 8-byte integer" },
    { value: "SMALLINT", label: "SMALLINT", description: "Signed 2-byte integer" },
    { value: "SERIAL", label: "SERIAL", description: "Auto-incrementing 4-byte integer" },
    { value: "BIGSERIAL", label: "BIGSERIAL", description: "Auto-incrementing 8-byte integer" },
    { value: "NUMERIC", label: "NUMERIC", description: "Exact numeric with precision" },
    { value: "DECIMAL", label: "DECIMAL", description: "Exact numeric (alias for NUMERIC)" },
    { value: "REAL", label: "REAL", description: "Single precision floating-point (4 bytes)" },
    { value: "DOUBLE PRECISION", label: "DOUBLE PRECISION", description: "Double precision floating-point (8 bytes)" },
    { value: "MONEY", label: "MONEY", description: "Currency amount" },
  ],
  "Text": [
    { value: "TEXT", label: "TEXT", description: "Variable unlimited length" },
    { value: "VARCHAR(255)", label: "VARCHAR(255)", description: "Variable length with limit" },
    { value: "VARCHAR(50)", label: "VARCHAR(50)", description: "Variable length (short)" },
    { value: "CHAR(1)", label: "CHAR(1)", description: "Fixed length character" },
    { value: "CHAR(10)", label: "CHAR(10)", description: "Fixed length (10 chars)" },
  ],
  "Date/Time": [
    { value: "TIMESTAMP", label: "TIMESTAMP", description: "Date and time (no timezone)" },
    { value: "TIMESTAMPTZ", label: "TIMESTAMPTZ", description: "Date and time with timezone" },
    { value: "DATE", label: "DATE", description: "Date only (no time)" },
    { value: "TIME", label: "TIME", description: "Time only (no date)" },
    { value: "TIMETZ", label: "TIMETZ", description: "Time with timezone" },
    { value: "INTERVAL", label: "INTERVAL", description: "Time interval" },
  ],
  "Boolean": [
    { value: "BOOLEAN", label: "BOOLEAN", description: "True/false value" },
  ],
  "UUID": [
    { value: "UUID", label: "UUID", description: "Universally unique identifier" },
  ],
  "JSON": [
    { value: "JSON", label: "JSON", description: "JSON data (text storage)" },
    { value: "JSONB", label: "JSONB", description: "JSON data (binary, indexed)" },
  ],
  "Binary": [
    { value: "BYTEA", label: "BYTEA", description: "Binary data" },
  ],
  "Network": [
    { value: "INET", label: "INET", description: "IPv4 or IPv6 host address" },
    { value: "CIDR", label: "CIDR", description: "IPv4 or IPv6 network address" },
    { value: "MACADDR", label: "MACADDR", description: "MAC address" },
  ],
  "Arrays": [
    { value: "TEXT[]", label: "TEXT[]", description: "Array of text" },
    { value: "INTEGER[]", label: "INTEGER[]", description: "Array of integers" },
    { value: "VARCHAR[]", label: "VARCHAR[]", description: "Array of varchar" },
  ],
};

const AUTO_GENERATE_OPTIONS: Record<string, { label: string; value: string; description: string }[]> = {
  "UUID": [
    { label: "gen_random_uuid()", value: "gen_random_uuid()", description: "Random UUID v4" },
  ],
  "TIMESTAMP": [
    { label: "NOW()", value: "NOW()", description: "Current date & time" },
    { label: "CURRENT_TIMESTAMP", value: "CURRENT_TIMESTAMP", description: "Transaction start time" },
  ],
  "TIMESTAMPTZ": [
    { label: "NOW()", value: "NOW()", description: "Current date & time with timezone" },
    { label: "CURRENT_TIMESTAMP", value: "CURRENT_TIMESTAMP", description: "Transaction start time" },
  ],
  "DATE": [
    { label: "CURRENT_DATE", value: "CURRENT_DATE", description: "Today's date" },
  ],
  "TIME": [
    { label: "CURRENT_TIME", value: "CURRENT_TIME", description: "Current time" },
  ],
  "TIMETZ": [
    { label: "CURRENT_TIME", value: "CURRENT_TIME", description: "Current time with timezone" },
  ],
  "BOOLEAN": [
    { label: "TRUE", value: "TRUE", description: "Default true" },
    { label: "FALSE", value: "FALSE", description: "Default false" },
  ],
  "TEXT": [
    { label: "Empty ''", value: "''", description: "Empty string" },
  ],
  "JSONB": [
    { label: "Empty {}", value: "'{}'::jsonb", description: "Empty JSON object" },
    { label: "Empty []", value: "'[]'::jsonb", description: "Empty JSON array" },
  ],
  "JSON": [
    { label: "Empty {}", value: "'{}'", description: "Empty JSON object" },
    { label: "Empty []", value: "'[]'", description: "Empty JSON array" },
  ],
};

function getAutoGenerateOptions(dataType: string, customType: string) {
  const type = (dataType === "CUSTOM" ? customType : dataType).toUpperCase().trim();
  if (AUTO_GENERATE_OPTIONS[type]) return AUTO_GENERATE_OPTIONS[type];
  if (type.startsWith("VARCHAR") || type.startsWith("CHAR")) return AUTO_GENERATE_OPTIONS["TEXT"] || [];
  if (type.startsWith("TIMESTAMP")) {
    return AUTO_GENERATE_OPTIONS[type.includes("TZ") ? "TIMESTAMPTZ" : "TIMESTAMP"] || [];
  }
  return [];
}

type ForeignKeyAction = "NO ACTION" | "RESTRICT" | "CASCADE" | "SET NULL" | "SET DEFAULT";

const FK_ACTIONS: { value: ForeignKeyAction; label: string; description: string }[] = [
  { value: "NO ACTION", label: "No Action", description: "Raise error if referenced rows exist" },
  { value: "RESTRICT", label: "Restrict", description: "Prevent delete/update (checked immediately)" },
  { value: "CASCADE", label: "Cascade", description: "Automatically delete/update related rows" },
  { value: "SET NULL", label: "Set NULL", description: "Set foreign key column to NULL" },
  { value: "SET DEFAULT", label: "Set Default", description: "Set foreign key to its default value" },
];

interface ColumnFormState {
  id: string;
  name: string;
  dataType: string;
  customType: string;
  isNullable: boolean;
  isPrimaryKey: boolean;
  isUnique: boolean;
  isForeignKey: boolean;
  foreignKeySchema: string;
  foreignKeyTable: string;
  foreignKeyColumn: string;
  foreignKeyOnDelete: ForeignKeyAction;
  foreignKeyOnUpdate: ForeignKeyAction;
  foreignKeyConstraintName: string;
  defaultValue: string;
  isExpanded: boolean;
}

const createEmptyColumn = (): ColumnFormState => ({
  id: Math.random().toString(36).substring(2, 11),
  name: "",
  dataType: "TEXT",
  customType: "",
  isNullable: true,
  isPrimaryKey: false,
  isUnique: false,
  isForeignKey: false,
  foreignKeySchema: "",
  foreignKeyTable: "",
  foreignKeyColumn: "",
  foreignKeyOnDelete: "NO ACTION",
  foreignKeyOnUpdate: "NO ACTION",
  foreignKeyConstraintName: "",
  defaultValue: "",
  isExpanded: true,
});

/**
 * Type Dropdown Component for selecting PostgreSQL types
 * Uses a portal to render outside of any overflow:hidden containers
 */
function TypeDropdown({
  value,
  onSelect,
  onClose,
  anchorRef,
}: {
  value: string;
  onSelect: (type: string) => void;
  onClose: () => void;
  anchorRef: React.RefObject<HTMLButtonElement | null>;
}) {
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const [search, setSearch] = useState("");
  const dropdownRef = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);

  // Auto-focus search input when dropdown opens
  useEffect(() => {
    setTimeout(() => searchInputRef.current?.focus(), 0);
  }, []);

  // Calculate position based on anchor element
  useLayoutEffect(() => {
    if (anchorRef.current) {
      const rect = anchorRef.current.getBoundingClientRect();
      setPosition({
        top: rect.bottom + 4,
        left: rect.left,
      });
    }
  }, [anchorRef]);

  // Adjust position if dropdown goes off screen
  useLayoutEffect(() => {
    if (dropdownRef.current) {
      const dropdown = dropdownRef.current;
      const rect = dropdown.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;

      let newTop = position.top;
      let newLeft = position.left;

      // Check if dropdown goes below viewport
      if (rect.bottom > viewportHeight - 10) {
        // Position above the anchor instead
        if (anchorRef.current) {
          const anchorRect = anchorRef.current.getBoundingClientRect();
          newTop = anchorRect.top - rect.height - 4;
        }
      }

      // Check if dropdown goes off right edge
      if (rect.right > viewportWidth - 10) {
        newLeft = viewportWidth - rect.width - 10;
      }

      if (newTop !== position.top || newLeft !== position.left) {
        setPosition({ top: newTop, left: newLeft });
      }
    }
  }, [position, anchorRef]);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (!target.closest(".type-dropdown") && !anchorRef.current?.contains(target)) {
        onClose();
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, [onClose, anchorRef]);

  // Filter types based on search
  const searchLower = search.toLowerCase();
  const filteredTypes = Object.entries(POSTGRES_TYPES)
    .map(([category, types]) => ({
      category,
      types: types.filter(
        (t) =>
          t.label.toLowerCase().includes(searchLower) ||
          t.description.toLowerCase().includes(searchLower)
      ),
    }))
    .filter((group) => group.types.length > 0);

  // Check if custom type matches search
  const showCustom =
    !search ||
    "custom".includes(searchLower) ||
    "custom type".includes(searchLower);

  return createPortal(
    <div
      ref={dropdownRef}
      className={cn(
        "type-dropdown fixed z-[100] w-72 max-h-80 flex flex-col",
        "bg-[var(--bg-secondary)] border border-[var(--border-color)]",
        "rounded-lg shadow-xl"
      )}
      style={{ top: position.top, left: position.left }}
    >
      {/* Search Input */}
      <div className="p-2 border-b border-[var(--border-color)] shrink-0">
        <div className="relative">
          <Search className="absolute left-2.5 top-1/2 -translate-y-1/2 w-4 h-4 text-[var(--text-muted)]" />
          <input
            ref={searchInputRef}
            type="text"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            placeholder="Search types..."
            autoCorrect="off"
            autoCapitalize="off"
            autoComplete="off"
            spellCheck={false}
            className={cn(
              "w-full h-8 pl-8 pr-3 rounded text-sm",
              "bg-[var(--bg-primary)] text-[var(--text-primary)]",
              "border border-[var(--border-color)]",
              "focus:border-[var(--accent)] focus:outline-none",
              "placeholder:text-[var(--text-muted)]"
            )}
          />
        </div>
      </div>

      {/* Types List */}
      <div className="flex-1 overflow-y-auto">
        {filteredTypes.map(({ category, types }) => (
          <div key={category}>
            <div className="px-3 py-1.5 text-xs font-medium text-[var(--text-muted)] bg-[var(--bg-tertiary)] sticky top-0">
              {category}
            </div>
            {types.map((type) => (
              <button
                key={type.value}
                onClick={() => onSelect(type.value)}
                className={cn(
                  "w-full px-3 py-1.5 text-left",
                  "hover:bg-[var(--bg-tertiary)] transition-colors",
                  value === type.value && "bg-[var(--accent)]/10"
                )}
              >
                <div className="text-sm text-[var(--text-primary)]">{type.label}</div>
                <div className="text-xs text-[var(--text-muted)]">{type.description}</div>
              </button>
            ))}
          </div>
        ))}
        {/* Custom Type Option */}
        {showCustom && (
          <div>
            <div className="px-3 py-1.5 text-xs font-medium text-[var(--text-muted)] bg-[var(--bg-tertiary)] sticky top-0">
              Other
            </div>
            <button
              onClick={() => onSelect("CUSTOM")}
              className={cn(
                "w-full px-3 py-1.5 text-left",
                "hover:bg-[var(--bg-tertiary)] transition-colors",
                value === "CUSTOM" && "bg-[var(--accent)]/10"
              )}
            >
              <div className="text-sm text-[var(--text-primary)]">Custom Type</div>
              <div className="text-xs text-[var(--text-muted)]">Enter any PostgreSQL type</div>
            </button>
          </div>
        )}
        {/* No results */}
        {filteredTypes.length === 0 && !showCustom && (
          <div className="px-3 py-4 text-sm text-[var(--text-muted)] text-center">
            No types found
          </div>
        )}
      </div>
    </div>,
    document.body
  );
}

/**
 * Column Editor Component for defining table columns (Sortable)
 */
function ColumnEditorRow({
  column,
  index,
  onUpdate,
  onRemove,
  onToggleExpanded,
  onBeforeEdit,
  canRemove,
  isDraggable = true,
  schemas,
  onFetchColumns,
  availableColumns,
  isLoadingColumns,
}: {
  column: ColumnFormState;
  index: number;
  onUpdate: (updates: Partial<ColumnFormState>) => void;
  onRemove: () => void;
  onToggleExpanded: () => void;
  onBeforeEdit?: () => void;
  canRemove: boolean;
  isDraggable?: boolean;
  schemas: { name: string; tables: { name: string; schema: string }[] }[];
  onFetchColumns: (schema: string, table: string) => void;
  availableColumns: { name: string; dataType: string; isPrimaryKey: boolean; isUnique: boolean }[];
  isLoadingColumns: boolean;
}) {
  const [showTypeDropdown, setShowTypeDropdown] = useState(false);
  const typeButtonRef = useRef<HTMLButtonElement>(null);

  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: column.id, disabled: !isDraggable });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  const getTypeLabel = () => {
    if (column.dataType === "CUSTOM") {
      return column.customType || "Custom...";
    }
    return column.dataType;
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        "border border-[var(--border-color)] rounded-lg overflow-hidden select-none",
        "bg-[var(--bg-secondary)]",
        isDragging && "opacity-50 shadow-lg"
      )}
    >
      {/* Column Header */}
      <div
        className={cn(
          "flex items-center gap-2 px-3 py-2 cursor-pointer",
          "hover:bg-[var(--bg-tertiary)] transition-colors"
        )}
        onClick={onToggleExpanded}
      >
        {isDraggable && (
          <button
            type="button"
            className="!cursor-grab active:!cursor-grabbing p-0.5 -m-0.5 rounded hover:bg-[var(--bg-tertiary)] touch-none"
            {...attributes}
            {...listeners}
            onClick={(e) => e.stopPropagation()}
          >
            <GripVertical className="w-4 h-4 text-[var(--text-muted)]" />
          </button>
        )}
        {column.isExpanded ? (
          <ChevronDown className="w-4 h-4 text-[var(--text-muted)]" />
        ) : (
          <ChevronRight className="w-4 h-4 text-[var(--text-muted)]" />
        )}

        <div className="flex-1 flex items-center gap-2 min-w-0">
          <span className="text-sm font-medium text-[var(--text-primary)] truncate">
            {column.name || `Column ${index + 1}`}
          </span>
          <span className="text-xs text-[var(--text-muted)] truncate">
            {getTypeLabel()}
          </span>
          {column.isPrimaryKey && (
            <Key className="w-3.5 h-3.5 text-yellow-500 shrink-0" />
          )}
        </div>

        {canRemove && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              onRemove();
            }}
            className="p-1 rounded text-[var(--text-muted)] hover:text-red-400 hover:bg-red-500/10 transition-colors"
          >
            <Trash2 className="w-4 h-4" />
          </button>
        )}
      </div>

      {/* Column Details (Expanded) */}
      {column.isExpanded && (
        <div className="px-3 pb-3 pt-1 space-y-3 border-t border-[var(--border-color)]">
          {/* Name and Type Row */}
          <div className="grid grid-cols-2 gap-3">
            <div>
              <label className="block text-xs text-[var(--text-muted)] mb-1">
                Name <span className="text-red-400">*</span>
              </label>
              <input
                type="text"
                value={column.name}
                onFocus={onBeforeEdit}
                onChange={(e) => onUpdate({ name: e.target.value })}
                placeholder="column_name"
                autoCorrect="off"
                autoCapitalize="off"
                autoComplete="off"
                spellCheck={false}
                className={cn(
                  "w-full h-8 px-2.5 rounded text-sm",
                  "bg-[var(--bg-primary)] text-[var(--text-primary)]",
                  "border border-[var(--border-color)]",
                  "focus:border-[var(--accent)] focus:outline-none",
                  "placeholder:text-[var(--text-muted)]"
                )}
              />
            </div>
            <div>
              <label className="block text-xs text-[var(--text-muted)] mb-1">
                Type <span className="text-red-400">*</span>
              </label>
              <button
                ref={typeButtonRef}
                type="button"
                onClick={() => setShowTypeDropdown(!showTypeDropdown)}
                className={cn(
                  "w-full h-8 px-2.5 rounded text-sm text-left",
                  "bg-[var(--bg-primary)] text-[var(--text-primary)]",
                  "border border-[var(--border-color)]",
                  "hover:border-[var(--accent)] focus:border-[var(--accent)] focus:outline-none",
                  "flex items-center justify-between"
                )}
              >
                <span className="truncate">{getTypeLabel()}</span>
                <ChevronDown className="w-4 h-4 text-[var(--text-muted)] shrink-0" />
              </button>

              {showTypeDropdown && (
                <TypeDropdown
                  value={column.dataType}
                  onSelect={(type) => {
                    onBeforeEdit?.();
                    onUpdate({ dataType: type });
                    setShowTypeDropdown(false);
                  }}
                  onClose={() => setShowTypeDropdown(false)}
                  anchorRef={typeButtonRef}
                />
              )}
            </div>
          </div>

          {/* Custom Type Input */}
          {column.dataType === "CUSTOM" && (
            <div>
              <label className="block text-xs text-[var(--text-muted)] mb-1">
                Custom Type <span className="text-red-400">*</span>
              </label>
              <input
                type="text"
                value={column.customType}
                onFocus={onBeforeEdit}
                onChange={(e) => onUpdate({ customType: e.target.value })}
                placeholder="e.g., VARCHAR(100), NUMERIC(10,2)"
                autoCorrect="off"
                autoCapitalize="off"
                autoComplete="off"
                spellCheck={false}
                className={cn(
                  "w-full h-8 px-2.5 rounded text-sm font-mono",
                  "bg-[var(--bg-primary)] text-[var(--text-primary)]",
                  "border border-[var(--border-color)]",
                  "focus:border-[var(--accent)] focus:outline-none",
                  "placeholder:text-[var(--text-muted)]"
                )}
              />
            </div>
          )}

          {/* Default Value */}
          <div>
            <label className="block text-xs text-[var(--text-muted)] mb-1">
              Default Value
            </label>
            <input
              type="text"
              value={column.defaultValue}
              onFocus={onBeforeEdit}
              onChange={(e) => onUpdate({ defaultValue: e.target.value })}
              placeholder="e.g., 0, 'text', NOW(), gen_random_uuid()"
              autoCorrect="off"
              autoCapitalize="off"
              autoComplete="off"
              spellCheck={false}
              className={cn(
                "w-full h-8 px-2.5 rounded text-sm font-mono",
                "bg-[var(--bg-primary)] text-[var(--text-primary)]",
                "border border-[var(--border-color)]",
                "focus:border-[var(--accent)] focus:outline-none",
                "placeholder:text-[var(--text-muted)]"
              )}
            />
            {(() => {
              const options = getAutoGenerateOptions(column.dataType, column.customType);
              if (options.length === 0) return null;
              return (
                <div className="flex items-center gap-1.5 mt-1.5 flex-wrap">
                  <Zap className="w-3 h-3 text-amber-400 shrink-0" />
                  {options.map((opt) => {
                    const isActive = column.defaultValue === opt.value;
                    return (
                      <button
                        key={opt.value}
                        type="button"
                        title={opt.description}
                        onClick={() => {
                          onBeforeEdit?.();
                          onUpdate({ defaultValue: isActive ? "" : opt.value });
                        }}
                        className={cn(
                          "px-2 py-0.5 rounded-full text-xs font-mono transition-colors",
                          isActive
                            ? "bg-amber-500/20 text-amber-300 border border-amber-500/40"
                            : "bg-[var(--bg-tertiary)] text-[var(--text-muted)] border border-transparent",
                          !isActive && "hover:text-[var(--text-primary)] hover:bg-[var(--bg-primary)]"
                        )}
                      >
                        {opt.label}
                      </button>
                    );
                  })}
                </div>
              );
            })()}
          </div>

          {/* Constraints Row */}
          <div className="flex items-center gap-4 flex-wrap">
            <Checkbox
              checked={column.isPrimaryKey}
              onChange={(checked) => {
                onBeforeEdit?.();
                onUpdate({
                  isPrimaryKey: checked,
                  isNullable: checked ? false : column.isNullable,
                });
              }}
              label="Primary Key"
            />

            <Checkbox
              checked={!column.isNullable}
              disabled={column.isPrimaryKey}
              onChange={(checked) => {
                onBeforeEdit?.();
                onUpdate({ isNullable: !checked });
              }}
              label="Not Null"
            />

            <Checkbox
              checked={column.isUnique}
              disabled={column.isPrimaryKey}
              onChange={(checked) => {
                onBeforeEdit?.();
                onUpdate({ isUnique: checked });
              }}
              label="Unique"
            />
          </div>

          {/* Foreign Key Reference - Separate Section */}
          <div className="pt-3 border-t border-[var(--border-color)]">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Link className="w-4 h-4 text-blue-400" />
                <span className="text-xs font-medium text-[var(--text-secondary)]">
                  Foreign Key Reference
                </span>
              </div>
              <Toggle
                checked={column.isForeignKey}
                onChange={(checked) => {
                  onBeforeEdit?.();
                  if (checked) {
                    const defaultSchema = schemas[0]?.name || "";
                    onUpdate({
                      isForeignKey: true,
                      foreignKeySchema: defaultSchema,
                      foreignKeyTable: "",
                      foreignKeyColumn: "",
                      foreignKeyOnDelete: "NO ACTION",
                      foreignKeyOnUpdate: "NO ACTION",
                    });
                  } else {
                    onUpdate({
                      isForeignKey: false,
                      foreignKeySchema: "",
                      foreignKeyTable: "",
                      foreignKeyColumn: "",
                      foreignKeyOnDelete: "NO ACTION",
                      foreignKeyOnUpdate: "NO ACTION",
                    });
                  }
                }}
              />
            </div>

            {column.isForeignKey && (
              <div className="space-y-3 mt-3">
                {/* References Row */}
                <div className="grid grid-cols-3 gap-2">
                  {/* Schema Select */}
                  <div>
                    <label className="block text-xs text-[var(--text-muted)] mb-1">
                      Schema
                    </label>
                    <Select
                      value={column.foreignKeySchema || undefined}
                      onValueChange={(value) => {
                        onBeforeEdit?.();
                        onUpdate({
                          foreignKeySchema: value,
                          foreignKeyTable: "",
                          foreignKeyColumn: "",
                        });
                      }}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select..." />
                      </SelectTrigger>
                      <SelectContent>
                        {schemas.map((s) => (
                          <SelectItem key={s.name} value={s.name}>
                            {s.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  {/* Table Select */}
                  <div>
                    <label className="block text-xs text-[var(--text-muted)] mb-1">
                      Table
                    </label>
                    <Select
                      value={column.foreignKeyTable || undefined}
                      onValueChange={(value) => {
                        onBeforeEdit?.();
                        onUpdate({
                          foreignKeyTable: value,
                          foreignKeyColumn: "",
                        });
                        if (value && column.foreignKeySchema) {
                          onFetchColumns(column.foreignKeySchema, value);
                        }
                      }}
                      disabled={!column.foreignKeySchema}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select..." />
                      </SelectTrigger>
                      <SelectContent>
                        {schemas
                          .find((s) => s.name === column.foreignKeySchema)
                          ?.tables.map((t) => (
                            <SelectItem key={t.name} value={t.name}>
                              {t.name}
                            </SelectItem>
                          ))}
                      </SelectContent>
                    </Select>
                  </div>

                  {/* Column Select - Only shows PK/UNIQUE columns (valid FK targets) */}
                  <div>
                    <label className="block text-xs text-[var(--text-muted)] mb-1">
                      Column
                    </label>
                    <Select
                      value={column.foreignKeyColumn || undefined}
                      onValueChange={(value) => {
                        onBeforeEdit?.();
                        onUpdate({ foreignKeyColumn: value });
                      }}
                      disabled={!column.foreignKeyTable || isLoadingColumns || availableColumns.length === 0}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder={
                          isLoadingColumns
                            ? "Loading..."
                            : column.foreignKeyTable && availableColumns.length === 0
                              ? "No valid targets"
                              : "Select..."
                        } />
                      </SelectTrigger>
                      <SelectContent>
                        {availableColumns.length === 0 ? (
                          <div className="px-2 py-3 text-xs text-[var(--text-muted)] text-center">
                            No columns with PRIMARY KEY or UNIQUE constraint
                          </div>
                        ) : (
                          availableColumns.map((col) => (
                            <SelectItem
                              key={col.name}
                              value={col.name}
                              description={col.isPrimaryKey ? "Primary Key" : "Unique"}
                            >
                              <span className="flex items-center gap-2">
                                {col.isPrimaryKey ? (
                                  <Key className="w-3 h-3 text-amber-400" />
                                ) : (
                                  <span className="w-3 h-3 text-xs text-blue-400 font-bold">U</span>
                                )}
                                {col.name}
                                <span className="text-[var(--text-muted)]">({col.dataType})</span>
                              </span>
                            </SelectItem>
                          ))
                        )}
                      </SelectContent>
                    </Select>
                    {column.foreignKeyTable && !isLoadingColumns && availableColumns.length === 0 && (
                      <p className="text-xs text-amber-400 mt-1">
                        Table has no PRIMARY KEY or UNIQUE columns
                      </p>
                    )}
                  </div>
                </div>

                {/* Actions Section */}
                <div>
                  <div className="flex items-center gap-2 mb-2">
                    <span className="text-xs font-medium text-[var(--text-secondary)]">
                      Referential Actions
                    </span>
                    <span className="text-xs text-[var(--text-muted)]">
                       What happens when referenced row changes
                    </span>
                  </div>
                  <div className="grid grid-cols-2 gap-3">
                    {/* ON DELETE */}
                    <div>
                      <label className="block text-xs text-[var(--text-muted)] mb-1">
                        On Delete
                      </label>
                      <Select
                        value={column.foreignKeyOnDelete}
                        onValueChange={(value) => {
                          onBeforeEdit?.();
                          onUpdate({ foreignKeyOnDelete: value as ForeignKeyAction });
                        }}
                      >
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {FK_ACTIONS.map((action) => (
                            <SelectItem
                              key={action.value}
                              value={action.value}
                              description={action.description}
                            >
                              {action.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>

                    {/* ON UPDATE */}
                    <div>
                      <label className="block text-xs text-[var(--text-muted)] mb-1">
                        On Update
                      </label>
                      <Select
                        value={column.foreignKeyOnUpdate}
                        onValueChange={(value) => {
                          onBeforeEdit?.();
                          onUpdate({ foreignKeyOnUpdate: value as ForeignKeyAction });
                        }}
                      >
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {FK_ACTIONS.map((action) => (
                            <SelectItem
                              key={action.value}
                              value={action.value}
                              description={action.description}
                            >
                              {action.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

/**
 * Static column display for drag overlay - maintains original dimensions
 */
function ColumnDragOverlay({
  column,
  index,
}: {
  column: ColumnFormState;
  index: number;
}) {
  const getTypeLabel = () => {
    if (column.dataType === "CUSTOM") {
      return column.customType || "Custom...";
    }
    return column.dataType;
  };

  return (
    <div
      className={cn(
        "border border-[var(--border-color)] rounded-lg overflow-hidden",
        "bg-[var(--bg-secondary)] shadow-xl",
        "cursor-grabbing"
      )}
    >
      {/* Column Header */}
      <div
        className={cn(
          "flex items-center gap-2 px-3 py-2",
          "bg-[var(--bg-tertiary)]"
        )}
      >
        <GripVertical className="w-4 h-4 text-[var(--text-muted)]" />
        {column.isExpanded ? (
          <ChevronDown className="w-4 h-4 text-[var(--text-muted)]" />
        ) : (
          <ChevronRight className="w-4 h-4 text-[var(--text-muted)]" />
        )}

        <div className="flex-1 flex items-center gap-2 min-w-0">
          <span className="text-sm font-medium text-[var(--text-primary)] truncate">
            {column.name || `Column ${index + 1}`}
          </span>
          <span className="text-xs text-[var(--text-muted)] truncate">
            {getTypeLabel()}
          </span>
          {column.isPrimaryKey && (
            <Key className="w-3.5 h-3.5 text-yellow-500 shrink-0" />
          )}
        </div>
      </div>

      {/* Column Details (Expanded) - show if expanded */}
      {column.isExpanded && (
        <div className="px-3 pb-3 pt-1 space-y-3 border-t border-[var(--border-color)]">
          <div className="grid grid-cols-2 gap-3">
            <div>
              <label className="block text-xs text-[var(--text-muted)] mb-1">Name</label>
              <div className="w-full h-8 px-2.5 rounded text-sm bg-[var(--bg-primary)] text-[var(--text-primary)] border border-[var(--border-color)] flex items-center">
                {column.name || <span className="text-[var(--text-muted)]">column_name</span>}
              </div>
            </div>
            <div>
              <label className="block text-xs text-[var(--text-muted)] mb-1">Type</label>
              <div className="w-full h-8 px-2.5 rounded text-sm bg-[var(--bg-primary)] text-[var(--text-primary)] border border-[var(--border-color)] flex items-center">
                {getTypeLabel()}
              </div>
            </div>
          </div>
          {column.defaultValue && (
            <div>
              <label className="block text-xs text-[var(--text-muted)] mb-1">Default Value</label>
              <div className="w-full h-8 px-2.5 rounded text-sm font-mono bg-[var(--bg-primary)] text-[var(--text-primary)] border border-[var(--border-color)] flex items-center">
                {column.defaultValue}
              </div>
            </div>
          )}
          <div className="flex items-center gap-4 text-xs text-[var(--text-secondary)]">
            {column.isPrimaryKey && <span>Primary Key</span>}
            {!column.isNullable && <span>Not Null</span>}
            {column.isUnique && <span>Unique</span>}
          </div>
        </div>
      )}
    </div>
  );
}

/**
 * Create Table Tab Content - Full tab view for creating new tables
 */
function CreateTableTabContent({ tab }: { tab: Tab }) {
  const { schemas } = useProjectStore();
  const { closeTab, addTab } = useUIStore();
  const migration = useMigration();

  const [tableName, setTableName] = useState("");
  const [selectedSchema, setSelectedSchema] = useState(tab.createTableSchema || "");
  const [columns, setColumns] = useState<ColumnFormState[]>([createEmptyColumn()]);
  const [showPreview, setShowPreview] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [activeId, setActiveId] = useState<string | null>(null);
  const [copied, setCopied] = useState(false);
  const [migrationResult, setMigrationResult] = useState<MigrationResult | null>(null);
  // FK column cache includes constraint info to filter valid FK targets
  // Key = "schema.table", value = columns (empty array means fetched but no valid targets)
  const [fkColumnsCache, setFkColumnsCache] = useState<Record<string, {
    name: string;
    dataType: string;
    isPrimaryKey: boolean;
    isUnique: boolean;
  }[]>>({});
  // Track tables currently being fetched to avoid showing error during load
  const [fkColumnsLoading, setFkColumnsLoading] = useState<Set<string>>(new Set());

  // Initialize schema on mount
  useEffect(() => {
    if (!selectedSchema && schemas.length > 0) {
      setSelectedSchema(tab.createTableSchema || schemas[0].name);
    }
  }, [schemas, selectedSchema, tab.createTableSchema]);

  const clearResult = useCallback(() => {
    setMigrationResult(null);
    setError(null);
  }, []);

  const updateColumn = useCallback((id: string, updates: Partial<ColumnFormState>) => {
    setColumns((prev) =>
      prev.map((col) => (col.id === id ? { ...col, ...updates } : col))
    );
    clearResult();
  }, [clearResult]);

  const addColumn = useCallback(() => {
    setColumns((prev) => [
      ...prev.map((col) => ({ ...col, isExpanded: false })),
      createEmptyColumn(),
    ]);
    clearResult();
  }, [clearResult]);

  const removeColumn = useCallback((id: string) => {
    setColumns((prev) => {
      if (prev.length <= 1) return prev;
      return prev.filter((col) => col.id !== id);
    });
    clearResult();
  }, [clearResult]);

  const toggleColumnExpanded = useCallback((id: string) => {
    setColumns((prev) =>
      prev.map((col) => (col.id === id ? { ...col, isExpanded: !col.isExpanded } : col))
    );
  }, []);

  // Drag and drop sensors
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveId(event.active.id as string);
  }, []);

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setColumns((prev) => {
        const oldIndex = prev.findIndex((col) => col.id === active.id);
        const newIndex = prev.findIndex((col) => col.id === over.id);
        return arrayMove(prev, oldIndex, newIndex);
      });
    }
    setActiveId(null);
  }, []);

  // Fetch columns for foreign key reference - only stores columns that are valid FK targets
  const fetchFkColumns = useCallback(async (schema: string, table: string) => {
    const cacheKey = `${schema}.${table}`;
    if (fkColumnsCache[cacheKey] !== undefined) return; // Already cached (even if empty)
    if (fkColumnsLoading.has(cacheKey)) return; // Already loading

    const connectionId = getCurrentConnectionId();
    if (!connectionId) return;

    // Mark as loading
    setFkColumnsLoading((prev) => new Set(prev).add(cacheKey));

    try {
      const cols = await invoke<{
        name: string;
        data_type: string;
        is_primary_key: boolean;
        is_unique: boolean;
      }[]>("get_columns", {
        connectionId,
        schema,
        table,
      });
      // Only include columns that are valid FK targets (PRIMARY KEY or UNIQUE)
      const validFkTargets = cols
        .filter((c) => c.is_primary_key || c.is_unique)
        .map((c) => ({
          name: c.name,
          dataType: c.data_type,
          isPrimaryKey: c.is_primary_key,
          isUnique: c.is_unique,
        }));
      setFkColumnsCache((prev) => ({
        ...prev,
        [cacheKey]: validFkTargets,
      }));
    } catch (err) {
      console.error("Failed to fetch columns for FK:", err);
      // Still cache empty array on error to prevent repeated attempts
      setFkColumnsCache((prev) => ({
        ...prev,
        [cacheKey]: [],
      }));
    } finally {
      // Remove from loading set
      setFkColumnsLoading((prev) => {
        const next = new Set(prev);
        next.delete(cacheKey);
        return next;
      });
    }
  }, [fkColumnsCache, fkColumnsLoading]);

  const getColumnDefinitions = (): ColumnDefinition[] => {
    return columns.map((col) => ({
      name: col.name.trim(),
      dataType: col.dataType === "CUSTOM" ? col.customType.trim() : col.dataType,
      isNullable: col.isNullable,
      isPrimaryKey: col.isPrimaryKey,
      isUnique: col.isUnique,
      defaultValue: col.defaultValue.trim(),
      references: col.isForeignKey && col.foreignKeySchema && col.foreignKeyTable && col.foreignKeyColumn
        ? {
            schema: col.foreignKeySchema,
            table: col.foreignKeyTable,
            column: col.foreignKeyColumn,
            onDelete: col.foreignKeyOnDelete,
            onUpdate: col.foreignKeyOnUpdate,
          }
        : undefined,
    }));
  };

  const generateSQL = (): string => {
    // Generate preview SQL even with incomplete data
    const schemaName = selectedSchema || "schema";
    const tblName = tableName.trim() || "table_name";

    const columnLines = columns.map((col, idx) => {
      const colName = col.name.trim() || `column_${idx + 1}`;
      const colType = col.dataType === "CUSTOM"
        ? (col.customType.trim() || "TYPE")
        : col.dataType;

      const parts: string[] = [`"${colName}"`, colType];

      if (col.isPrimaryKey) {
        parts.push("PRIMARY KEY");
      } else {
        if (!col.isNullable) parts.push("NOT NULL");
        if (col.isUnique) parts.push("UNIQUE");
      }

      if (col.defaultValue.trim()) {
        parts.push(`DEFAULT ${col.defaultValue.trim()}`);
      }

      // Add foreign key reference
      if (col.isForeignKey && col.foreignKeySchema && col.foreignKeyTable && col.foreignKeyColumn) {
        let fkRef = `REFERENCES "${col.foreignKeySchema}"."${col.foreignKeyTable}"("${col.foreignKeyColumn}")`;
        if (col.foreignKeyOnDelete && col.foreignKeyOnDelete !== "NO ACTION") {
          fkRef += ` ON DELETE ${col.foreignKeyOnDelete}`;
        }
        if (col.foreignKeyOnUpdate && col.foreignKeyOnUpdate !== "NO ACTION") {
          fkRef += ` ON UPDATE ${col.foreignKeyOnUpdate}`;
        }
        parts.push(fkRef);
      }

      return `  ${parts.join(" ")}`;
    });

    return `CREATE TABLE "${schemaName}"."${tblName}" (\n${columnLines.join(",\n")}\n)`;
  };

  const validate = (): boolean => {
    setError(null);

    if (!tableName.trim()) {
      setError("Table name is required");
      return false;
    }

    if (!selectedSchema) {
      setError("Please select a schema");
      return false;
    }

    for (const col of columns) {
      if (!col.name.trim()) {
        setError("All columns must have a name");
        return false;
      }
      if (col.dataType === "CUSTOM" && !col.customType.trim()) {
        setError(`Please specify a custom type for column "${col.name}"`);
        return false;
      }
    }

    const names = columns.map((c) => c.name.trim().toLowerCase());
    const duplicates = names.filter((name, index) => names.indexOf(name) !== index);
    if (duplicates.length > 0) {
      setError(`Duplicate column name: "${duplicates[0]}"`);
      return false;
    }

    return true;
  };

  const handleDryRun = async () => {
    if (!validate()) return;
    setMigrationResult(null);

    try {
      const sql = generateCreateTableSQL(selectedSchema, tableName.trim(), getColumnDefinitions());
      const result = await migration.mutateAsync({
        statements: [sql],
        dry_run: true,
      });
      setMigrationResult(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Dry run failed");
    }
  };

  const handleApply = async () => {
    if (!validate()) return;
    setMigrationResult(null);
    setSuccess(false);

    try {
      const sql = generateCreateTableSQL(selectedSchema, tableName.trim(), getColumnDefinitions());
      const result = await migration.mutateAsync({
        statements: [sql],
        dry_run: false,
      });
      setMigrationResult(result);

      if (result.ok && result.committed) {
        setSuccess(true);
        // Open the new table in a tab and close this create tab after a brief delay
        setTimeout(() => {
          addTab({
            id: `table-${selectedSchema}-${tableName.trim()}-${Date.now()}`,
            type: "table",
            title: tableName.trim(),
            schema: selectedSchema,
            table: tableName.trim(),
          });
          closeTab(tab.id);
        }, 1000);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create table");
    }
  };

  const previewSQL = generateSQL();
  const isDryRunning = migration.isPending && migration.variables?.dry_run === true;
  const isApplying = migration.isPending && migration.variables?.dry_run === false;

  return (
    <div className="h-full flex flex-col bg-[var(--bg-primary)]">
      {/* Header */}
      <div className="flex items-center justify-between px-6 py-4 border-b border-[var(--border-color)] shrink-0">
        <div className="flex items-center gap-3">
          <div className="p-2 rounded-lg bg-purple-500/10">
            <Table className="w-5 h-5 text-purple-400" />
          </div>
          <div>
            <h2 className="text-base font-semibold text-[var(--text-primary)]">
              Create New Table
            </h2>
            <p className="text-xs text-[var(--text-muted)]">
              Define your table structure with columns and constraints
            </p>
          </div>
        </div>

        <div className="flex items-center gap-2">
          <button
            onClick={handleDryRun}
            disabled={isDryRunning || isApplying || !tableName.trim() || success}
            className={cn(
              "flex items-center gap-2 px-4 py-2 text-sm rounded-lg",
              "bg-[var(--bg-tertiary)] text-[var(--text-primary)]",
              "border border-[var(--border-color)]",
              "hover:bg-[var(--bg-secondary)] transition-colors",
              "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
          >
            {isDryRunning ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin" />
                Validating...
              </>
            ) : (
              <>
                <Play className="w-4 h-4" />
                Dry Run
              </>
            )}
          </button>
          <button
            onClick={handleApply}
            disabled={isDryRunning || isApplying || !tableName.trim() || success}
            className={cn(
              "flex items-center gap-2 px-4 py-2 text-sm rounded-lg",
              success
                ? "bg-green-500 text-white"
                : "bg-purple-500 text-white hover:bg-purple-600",
              "transition-colors",
              "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
          >
            {isApplying ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin" />
                Applying...
              </>
            ) : success ? (
              <>
                <CheckCircle className="w-4 h-4" />
                Created!
              </>
            ) : (
              <>
                <Rocket className="w-4 h-4" />
                Apply
              </>
            )}
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        <div className="max-w-3xl mx-auto p-6 space-y-6">
          {/* Success Message */}
          {success && (
            <div className="flex items-start gap-3 p-4 rounded-lg bg-green-500/10 border border-green-500/20">
              <CheckCircle className="w-5 h-5 text-green-400 shrink-0 mt-0.5" />
              <div>
                <p className="text-sm font-medium text-green-400">
                  Table "{selectedSchema}.{tableName}" created successfully!
                </p>
                <p className="text-xs text-green-400/70 mt-1">
                  Opening table view...
                </p>
              </div>
            </div>
          )}

          {/* Error Display */}
          {error && (
            <div className="flex items-start gap-3 p-4 rounded-lg bg-red-500/10 border border-red-500/20">
              <AlertCircle className="w-5 h-5 text-red-400 shrink-0 mt-0.5" />
              <p className="text-sm text-red-400">{error}</p>
            </div>
          )}

          {/* Migration Results */}
          {migrationResult && (
            <MigrationResultPanel result={migrationResult} />
          )}

          {/* Table Name and Schema */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
                Schema
              </label>
              <Select
                value={selectedSchema || undefined}
                onValueChange={(v) => { setSelectedSchema(v); clearResult(); }}
                disabled={success}
              >
                <SelectTrigger className="h-10 rounded-lg bg-[var(--bg-secondary)]">
                  <SelectValue placeholder="Select schema..." />
                </SelectTrigger>
                <SelectContent>
                  {schemas.map((schema) => (
                    <SelectItem key={schema.name} value={schema.name}>
                      {schema.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div>
              <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
                Table Name <span className="text-red-400">*</span>
              </label>
              <input
                type="text"
                value={tableName}
                onChange={(e) => {
                  setTableName(e.target.value);
                  clearResult();
                }}
                disabled={success}
                placeholder="users"
                autoCorrect="off"
                autoCapitalize="off"
                autoComplete="off"
                spellCheck={false}
                className={cn(
                  "w-full h-10 px-3 rounded-lg text-sm",
                  "bg-[var(--bg-secondary)] text-[var(--text-primary)]",
                  "border border-[var(--border-color)]",
                  "focus:border-[var(--accent)] focus:outline-none",
                  "placeholder:text-[var(--text-muted)]",
                  "disabled:opacity-50"
                )}
              />
            </div>
          </div>

          {/* Columns Section */}
          <div>
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-[var(--text-secondary)]">
                Columns
              </label>
              <span className="text-xs text-[var(--text-muted)]">
                {columns.length} column{columns.length !== 1 ? "s" : ""}
              </span>
            </div>

            <DndContext
              sensors={sensors}
              collisionDetection={closestCenter}
              onDragStart={handleDragStart}
              onDragEnd={handleDragEnd}
            >
              <SortableContext
                items={columns.map((c) => c.id)}
                strategy={verticalListSortingStrategy}
              >
                <div className="space-y-2">
                  {columns.map((column, index) => (
                    <ColumnEditorRow
                      key={column.id}
                      column={column}
                      index={index}
                      onUpdate={(updates) => updateColumn(column.id, updates)}
                      onRemove={() => removeColumn(column.id)}
                      onToggleExpanded={() => toggleColumnExpanded(column.id)}
                      canRemove={columns.length > 1 && !success}
                      schemas={schemas}
                      onFetchColumns={fetchFkColumns}
                      availableColumns={
                        column.foreignKeySchema && column.foreignKeyTable
                          ? fkColumnsCache[`${column.foreignKeySchema}.${column.foreignKeyTable}`] || []
                          : []
                      }
                      isLoadingColumns={
                        column.foreignKeySchema && column.foreignKeyTable
                          ? fkColumnsLoading.has(`${column.foreignKeySchema}.${column.foreignKeyTable}`)
                          : false
                      }
                    />
                  ))}
                </div>
              </SortableContext>
              <DragOverlay>
                {activeId ? (
                  <ColumnDragOverlay
                    column={columns.find((c) => c.id === activeId)!}
                    index={columns.findIndex((c) => c.id === activeId)}
                  />
                ) : null}
              </DragOverlay>
            </DndContext>

            {!success && (
              <button
                onClick={addColumn}
                className={cn(
                  "w-full mt-3 flex items-center justify-center gap-2 px-4 py-3 rounded-lg",
                  "border border-dashed border-[var(--border-color)]",
                  "text-sm text-[var(--text-muted)]",
                  "hover:border-purple-500/50 hover:text-purple-400",
                  "transition-colors"
                )}
              >
                <Plus className="w-4 h-4" />
                Add Column
              </button>
            )}
          </div>

          {/* SQL Preview */}
          <div>
            <div className="flex items-center justify-between">
              <button
                onClick={() => setShowPreview(!showPreview)}
                className="flex items-center gap-2 text-sm font-medium text-[var(--text-secondary)] hover:text-[var(--text-primary)] transition-colors"
              >
                {showPreview ? (
                  <ChevronDown className="w-4 h-4" />
                ) : (
                  <ChevronRight className="w-4 h-4" />
                )}
                <Code className="w-4 h-4" />
                Preview SQL
              </button>
              {showPreview && (
                <button
                  onClick={() => {
                    navigator.clipboard.writeText(previewSQL);
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                  }}
                  className={cn(
                    "flex items-center gap-1.5 px-2 py-1 text-xs rounded",
                    "transition-colors",
                    copied
                      ? "text-green-400 bg-green-500/10"
                      : "text-[var(--text-muted)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]"
                  )}
                >
                  {copied ? (
                    <>
                      <Check className="w-3.5 h-3.5" />
                      Copied!
                    </>
                  ) : (
                    <>
                      <Copy className="w-3.5 h-3.5" />
                      Copy
                    </>
                  )}
                </button>
              )}
            </div>
            {showPreview && (
              <div className="mt-5">
                <CodeBlock code={previewSQL} language="sql" />
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

/**
 * Convert backend ColumnInfo to ColumnFormState for the editor
 */
function columnInfoToFormState(col: FullColumnInfo): ColumnFormState {
  return {
    id: `col-${col.ordinal_position}-${col.name}`,
    name: col.name,
    dataType: col.data_type,
    customType: "",
    isNullable: col.is_nullable,
    isPrimaryKey: col.is_primary_key,
    isUnique: col.is_unique,
    isForeignKey: col.is_foreign_key,
    foreignKeySchema: col.foreign_key_info?.referenced_schema || "",
    foreignKeyTable: col.foreign_key_info?.referenced_table || "",
    foreignKeyColumn: col.foreign_key_info?.referenced_column || "",
    foreignKeyOnDelete: "NO ACTION",
    foreignKeyOnUpdate: "NO ACTION",
    foreignKeyConstraintName: col.foreign_key_info?.constraint_name || "",
    defaultValue: col.default_value || "",
    isExpanded: false,
  };
}

function formStateToAlterDef(col: ColumnFormState): AlterColumnDef {
  return {
    id: col.id,
    name: col.name.trim(),
    dataType: col.dataType === "CUSTOM" ? col.customType.trim() : col.dataType,
    isNullable: col.isNullable,
    isPrimaryKey: col.isPrimaryKey,
    isUnique: col.isUnique,
    defaultValue: col.defaultValue.trim(),
    isForeignKey: col.isForeignKey,
    foreignKeySchema: col.foreignKeySchema,
    foreignKeyTable: col.foreignKeyTable,
    foreignKeyColumn: col.foreignKeyColumn,
    foreignKeyOnDelete: col.foreignKeyOnDelete,
    foreignKeyOnUpdate: col.foreignKeyOnUpdate,
    foreignKeyConstraintName: col.foreignKeyConstraintName,
  };
}

/**
 * Edit Table Tab Content - Modify an existing table's structure
 */
function EditTableTabContent({ tab }: { tab: Tab }) {
  const { schemas } = useProjectStore();
  const { closeTab, addTab } = useUIStore();
  const migration = useMigration();

  const schemaName = tab.schema || "";
  const originalTableName = tab.table || "";

  const { data: columnData, isLoading, dataUpdatedAt } = useTableColumns(schemaName, originalTableName);

  const [tableName, setTableName] = useState(originalTableName);
  const [columns, setColumns] = useState<ColumnFormState[]>([]);
  const [originalColumns, setOriginalColumns] = useState<ColumnFormState[]>([]);
  const [initialized, setInitialized] = useState(false);
  const [lastDataUpdatedAt, setLastDataUpdatedAt] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [migrationResult, setMigrationResult] = useState<MigrationResult | null>(null);
  const [activeId, setActiveId] = useState<string | null>(null);
  const [copied, setCopied] = useState(false);
  // FK column cache
  const [fkColumnsCache, setFkColumnsCache] = useState<Record<string, {
    name: string;
    dataType: string;
    isPrimaryKey: boolean;
    isUnique: boolean;
  }[]>>({});
  const [fkColumnsLoading, setFkColumnsLoading] = useState<Set<string>>(new Set());

  // Undo/redo history
  const undoStack = useRef<{ tableName: string; columns: ColumnFormState[] }[]>([]);
  const redoStack = useRef<{ tableName: string; columns: ColumnFormState[] }[]>([]);
  const [undoCount, setUndoCount] = useState(0); // triggers re-render when stacks change
  const [redoCount, setRedoCount] = useState(0);

  const pushUndo = useCallback((snapshot: { tableName: string; columns: ColumnFormState[] }) => {
    undoStack.current.push(snapshot);
    redoStack.current = [];
    setUndoCount(undoStack.current.length);
    setRedoCount(0);
  }, []);

  const undo = useCallback(() => {
    const snapshot = undoStack.current.pop();
    if (!snapshot) return;
    // Push current state to redo stack
    redoStack.current.push({ tableName, columns });
    setTableName(snapshot.tableName);
    setColumns(snapshot.columns);
    setMigrationResult(null);
    setError(null);
    setUndoCount(undoStack.current.length);
    setRedoCount(redoStack.current.length);
  }, [tableName, columns]);

  const redo = useCallback(() => {
    const snapshot = redoStack.current.pop();
    if (!snapshot) return;
    // Push current state to undo stack
    undoStack.current.push({ tableName, columns });
    setTableName(snapshot.tableName);
    setColumns(snapshot.columns);
    setMigrationResult(null);
    setError(null);
    setUndoCount(undoStack.current.length);
    setRedoCount(redoStack.current.length);
  }, [tableName, columns]);

  // Keyboard shortcuts: Cmd+Z / Ctrl+Z for undo, Cmd+Shift+Z / Ctrl+Shift+Z for redo
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === "z") {
        e.preventDefault();
        if (e.shiftKey) {
          redo();
        } else {
          undo();
        }
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [undo, redo]);

  // Initialize columns from fetched data, and re-sync when backend data changes (e.g. after apply)
  useEffect(() => {
    if (columnData && dataUpdatedAt > lastDataUpdatedAt) {
      const formCols = columnData.map(columnInfoToFormState);
      setOriginalColumns(formCols);
      setColumns(formCols);
      setInitialized(true);
      setLastDataUpdatedAt(dataUpdatedAt);
      setMigrationResult(null);
      setError(null);
      undoStack.current = [];
      redoStack.current = [];
      setUndoCount(0);
      setRedoCount(0);
    }
  }, [columnData, dataUpdatedAt, lastDataUpdatedAt]);

  const clearResult = useCallback(() => {
    setMigrationResult(null);
    setError(null);
  }, []);

  const saveSnapshot = useCallback(() => {
    pushUndo({ tableName, columns });
  }, [pushUndo, tableName, columns]);

  const updateColumn = useCallback((id: string, updates: Partial<ColumnFormState>) => {
    setColumns((prev) =>
      prev.map((col) => (col.id === id ? { ...col, ...updates } : col))
    );
    clearResult();
  }, [clearResult]);

  const addColumn = useCallback(() => {
    pushUndo({ tableName, columns });
    setColumns((prev) => [
      ...prev.map((col) => ({ ...col, isExpanded: false })),
      createEmptyColumn(),
    ]);
    clearResult();
  }, [clearResult, pushUndo, tableName, columns]);

  const removeColumn = useCallback((id: string) => {
    pushUndo({ tableName, columns });
    setColumns((prev) => {
      if (prev.length <= 1) return prev;
      return prev.filter((col) => col.id !== id);
    });
    clearResult();
  }, [clearResult, pushUndo, tableName, columns]);

  const toggleColumnExpanded = useCallback((id: string) => {
    setColumns((prev) =>
      prev.map((col) => (col.id === id ? { ...col, isExpanded: !col.isExpanded } : col))
    );
  }, []);

  // Drag and drop
  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 8 } }),
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const handleDragStart = useCallback((event: DragStartEvent) => {
    setActiveId(event.active.id as string);
  }, []);

  const handleDragEnd = useCallback((event: DragEndEvent) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      pushUndo({ tableName, columns });
      setColumns((prev) => {
        const oldIndex = prev.findIndex((col) => col.id === active.id);
        const newIndex = prev.findIndex((col) => col.id === over.id);
        return arrayMove(prev, oldIndex, newIndex);
      });
    }
    setActiveId(null);
  }, [pushUndo, tableName, columns]);

  // Fetch FK columns
  const fetchFkColumns = useCallback(async (fkSchema: string, fkTable: string) => {
    const cacheKey = `${fkSchema}.${fkTable}`;
    if (fkColumnsCache[cacheKey] !== undefined) return;
    if (fkColumnsLoading.has(cacheKey)) return;

    const connectionId = getCurrentConnectionId();
    if (!connectionId) return;

    setFkColumnsLoading((prev) => new Set(prev).add(cacheKey));

    try {
      const cols = await invoke<{
        name: string;
        data_type: string;
        is_primary_key: boolean;
        is_unique: boolean;
      }[]>("get_columns", { connectionId, schema: fkSchema, table: fkTable });

      const validFkTargets = cols
        .filter((c) => c.is_primary_key || c.is_unique)
        .map((c) => ({
          name: c.name,
          dataType: c.data_type,
          isPrimaryKey: c.is_primary_key,
          isUnique: c.is_unique,
        }));
      setFkColumnsCache((prev) => ({ ...prev, [cacheKey]: validFkTargets }));
    } catch {
      setFkColumnsCache((prev) => ({ ...prev, [cacheKey]: [] }));
    } finally {
      setFkColumnsLoading((prev) => {
        const next = new Set(prev);
        next.delete(cacheKey);
        return next;
      });
    }
  }, [fkColumnsCache, fkColumnsLoading]);

  // Generate ALTER SQL from diff
  const generateSQL = (): string[] => {
    return generateAlterTableSQL(
      schemaName,
      originalTableName,
      originalColumns.map(formStateToAlterDef),
      columns.map(formStateToAlterDef),
      tableName !== originalTableName ? tableName.trim() : undefined
    );
  };

  const validate = (): boolean => {
    for (const col of columns) {
      if (!col.name.trim()) {
        setError("All columns must have a name");
        return false;
      }
      if (col.dataType === "CUSTOM" && !col.customType.trim()) {
        setError(`Please specify a custom type for column "${col.name}"`);
        return false;
      }
    }

    const names = columns.map((c) => c.name.trim().toLowerCase());
    const duplicates = names.filter((name, index) => names.indexOf(name) !== index);
    if (duplicates.length > 0) {
      setError(`Duplicate column name: "${duplicates[0]}"`);
      return false;
    }

    const stmts = generateSQL();
    if (stmts.length === 0) {
      setError("No changes to apply");
      return false;
    }

    return true;
  };

  const handleDryRun = async () => {
    setError(null);
    setMigrationResult(null);
    if (!validate()) return;

    try {
      const result = await migration.mutateAsync({
        statements: generateSQL(),
        dry_run: true,
      });
      setMigrationResult(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Dry run failed");
    }
  };

  const handleApply = async () => {
    setError(null);
    setMigrationResult(null);
    if (!validate()) return;

    try {
      const result = await migration.mutateAsync({
        statements: generateSQL(),
        dry_run: false,
      });
      setMigrationResult(result);

      if (result.ok && result.committed) {
        // If table was renamed, open the new table; otherwise just close
        const finalTableName = tableName.trim() || originalTableName;
        setTimeout(() => {
          addTab({
            id: `table-${schemaName}-${finalTableName}-${Date.now()}`,
            type: "table",
            title: finalTableName,
            schema: schemaName,
            table: finalTableName,
          });
          closeTab(tab.id);
        }, 1000);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to apply changes");
    }
  };

  const alterStatements = initialized ? generateSQL() : [];
  const hasChanges = alterStatements.length > 0;
  const isDryRunning = migration.isPending && migration.variables?.dry_run === true;
  const isApplying = migration.isPending && migration.variables?.dry_run === false;

  if (isLoading || !initialized) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="flex items-center gap-3 text-[var(--text-muted)]">
          <Loader2 className="w-5 h-5 animate-spin" />
          <span className="text-sm">Loading table structure...</span>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col bg-[var(--bg-primary)]">
      {/* Header */}
      <div className="flex items-center justify-between px-6 py-4 border-b border-[var(--border-color)] shrink-0">
        <div className="flex items-center gap-3">
          <div className="p-2 rounded-lg bg-blue-500/10">
            <Settings className="w-5 h-5 text-blue-400" />
          </div>
          <div>
            <h2 className="text-base font-semibold text-[var(--text-primary)]">
              Edit Table
            </h2>
            <p className="text-xs text-[var(--text-muted)]">
              {schemaName}.{originalTableName}
            </p>
          </div>
        </div>

        <div className="flex items-center gap-2">
          <div className="flex items-center gap-1 mr-2">
            <button
              onClick={undo}
              disabled={undoCount === 0}
              title="Undo (Cmd+Z)"
              className={cn(
                "p-2 rounded-lg text-[var(--text-muted)]",
                "hover:bg-[var(--bg-tertiary)] hover:text-[var(--text-primary)]",
                "transition-colors",
                "disabled:opacity-30 disabled:cursor-not-allowed disabled:hover:bg-transparent disabled:hover:text-[var(--text-muted)]"
              )}
            >
              <Undo2 className="w-4 h-4" />
            </button>
            <button
              onClick={redo}
              disabled={redoCount === 0}
              title="Redo (Cmd+Shift+Z)"
              className={cn(
                "p-2 rounded-lg text-[var(--text-muted)]",
                "hover:bg-[var(--bg-tertiary)] hover:text-[var(--text-primary)]",
                "transition-colors",
                "disabled:opacity-30 disabled:cursor-not-allowed disabled:hover:bg-transparent disabled:hover:text-[var(--text-muted)]"
              )}
            >
              <Redo2 className="w-4 h-4" />
            </button>
          </div>
          <button
            onClick={handleDryRun}
            disabled={isDryRunning || isApplying || !hasChanges}
            className={cn(
              "flex items-center gap-2 px-4 py-2 text-sm rounded-lg",
              "bg-[var(--bg-tertiary)] text-[var(--text-primary)]",
              "border border-[var(--border-color)]",
              "hover:bg-[var(--bg-secondary)] transition-colors",
              "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
          >
            {isDryRunning ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin" />
                Validating...
              </>
            ) : (
              <>
                <Play className="w-4 h-4" />
                Dry Run
              </>
            )}
          </button>
          <button
            onClick={handleApply}
            disabled={isDryRunning || isApplying || !hasChanges}
            className={cn(
              "flex items-center gap-2 px-4 py-2 text-sm rounded-lg",
              "bg-blue-500 text-white hover:bg-blue-600",
              "transition-colors",
              "disabled:opacity-50 disabled:cursor-not-allowed"
            )}
          >
            {isApplying ? (
              <>
                <Loader2 className="w-4 h-4 animate-spin" />
                Applying...
              </>
            ) : (
              <>
                <Rocket className="w-4 h-4" />
                Apply
              </>
            )}
          </button>
        </div>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        <div className="max-w-3xl mx-auto p-6 space-y-6">
          {/* Error Display */}
          {error && (
            <div className="flex items-start gap-3 p-4 rounded-lg bg-red-500/10 border border-red-500/20">
              <AlertCircle className="w-5 h-5 text-red-400 shrink-0 mt-0.5" />
              <p className="text-sm text-red-400">{error}</p>
            </div>
          )}

          {/* Migration Results */}
          {migrationResult && (
            <MigrationResultPanel result={migrationResult} />
          )}

          {/* Table Name */}
          <div className="max-w-sm">
            <label className="block text-sm font-medium text-[var(--text-secondary)] mb-2">
              Table Name
            </label>
            <input
              type="text"
              value={tableName}
              onFocus={() => {
                pushUndo({ tableName, columns });
              }}
              onChange={(e) => {
                setTableName(e.target.value);
                clearResult();
              }}
              autoCorrect="off"
              autoCapitalize="off"
              autoComplete="off"
              spellCheck={false}
              className={cn(
                "w-full h-10 px-3 rounded-lg text-sm",
                "bg-[var(--bg-secondary)] text-[var(--text-primary)]",
                "border border-[var(--border-color)]",
                "focus:border-[var(--accent)] focus:outline-none"
              )}
            />
            {tableName !== originalTableName && tableName.trim() && (
              <p className="text-xs text-blue-400 mt-1">
                Will rename table from "{originalTableName}" to "{tableName.trim()}"
              </p>
            )}
          </div>

          {/* Columns Section */}
          <div>
            <div className="flex items-center justify-between mb-3">
              <label className="text-sm font-medium text-[var(--text-secondary)]">
                Columns
              </label>
              <span className="text-xs text-[var(--text-muted)]">
                {columns.length} column{columns.length !== 1 ? "s" : ""}
              </span>
            </div>

            {/* Existing columns (not draggable) */}
            {(() => {
              const originalIds = new Set(originalColumns.map((c) => c.id));
              const existingCols = columns.filter((c) => originalIds.has(c.id));
              const newCols = columns.filter((c) => !originalIds.has(c.id));

              return (
                <>
                  <div className="space-y-2">
                    {existingCols.map((column, index) => (
                      <ColumnEditorRow
                        key={column.id}
                        column={column}
                        index={index}
                        onUpdate={(updates) => updateColumn(column.id, updates)}
                        onRemove={() => removeColumn(column.id)}
                        onToggleExpanded={() => toggleColumnExpanded(column.id)}
                        onBeforeEdit={saveSnapshot}
                        canRemove={columns.length > 1}
                        isDraggable={false}
                        schemas={schemas}
                        onFetchColumns={fetchFkColumns}
                        availableColumns={
                          column.foreignKeySchema && column.foreignKeyTable
                            ? fkColumnsCache[`${column.foreignKeySchema}.${column.foreignKeyTable}`] || []
                            : []
                        }
                        isLoadingColumns={
                          column.foreignKeySchema && column.foreignKeyTable
                            ? fkColumnsLoading.has(`${column.foreignKeySchema}.${column.foreignKeyTable}`)
                            : false
                        }
                      />
                    ))}
                  </div>

                  {/* New columns (draggable) */}
                  {newCols.length > 0 && (
                    <DndContext
                      sensors={sensors}
                      collisionDetection={closestCenter}
                      onDragStart={handleDragStart}
                      onDragEnd={handleDragEnd}
                    >
                      <SortableContext
                        items={newCols.map((c) => c.id)}
                        strategy={verticalListSortingStrategy}
                      >
                        <div className="space-y-2 mt-2">
                          {newCols.map((column) => (
                            <ColumnEditorRow
                              key={column.id}
                              column={column}
                              index={existingCols.length + newCols.indexOf(column)}
                              onUpdate={(updates) => updateColumn(column.id, updates)}
                              onRemove={() => removeColumn(column.id)}
                              onToggleExpanded={() => toggleColumnExpanded(column.id)}
                              onBeforeEdit={saveSnapshot}
                              canRemove={columns.length > 1}
                              isDraggable={true}
                              schemas={schemas}
                              onFetchColumns={fetchFkColumns}
                              availableColumns={
                                column.foreignKeySchema && column.foreignKeyTable
                                  ? fkColumnsCache[`${column.foreignKeySchema}.${column.foreignKeyTable}`] || []
                                  : []
                              }
                              isLoadingColumns={
                                column.foreignKeySchema && column.foreignKeyTable
                                  ? fkColumnsLoading.has(`${column.foreignKeySchema}.${column.foreignKeyTable}`)
                                  : false
                              }
                            />
                          ))}
                        </div>
                      </SortableContext>
                      <DragOverlay>
                        {activeId ? (
                          <ColumnDragOverlay
                            column={columns.find((c) => c.id === activeId)!}
                            index={columns.findIndex((c) => c.id === activeId)}
                          />
                        ) : null}
                      </DragOverlay>
                    </DndContext>
                  )}
                </>
              );
            })()}

            <button
              onClick={addColumn}
              className={cn(
                "w-full mt-3 flex items-center justify-center gap-2 px-4 py-3 rounded-lg",
                "border border-dashed border-[var(--border-color)]",
                "text-sm text-[var(--text-muted)]",
                "hover:border-blue-500/50 hover:text-blue-400",
                "transition-colors"
              )}
            >
              <Plus className="w-4 h-4" />
              Add Column
            </button>
          </div>

          {/* SQL Preview */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center gap-2 text-sm font-medium text-[var(--text-secondary)]">
                <Code className="w-4 h-4" />
                ALTER Statements
                {hasChanges && (
                  <span className="text-xs font-normal text-[var(--text-muted)]">
                    ({alterStatements.length} statement{alterStatements.length !== 1 ? "s" : ""})
                  </span>
                )}
              </div>
              {hasChanges && (
                <button
                  onClick={() => {
                    navigator.clipboard.writeText(alterStatements.join(";\n") + ";");
                    setCopied(true);
                    setTimeout(() => setCopied(false), 2000);
                  }}
                  className={cn(
                    "flex items-center gap-1.5 px-2 py-1 text-xs rounded",
                    "transition-colors",
                    copied
                      ? "text-green-400 bg-green-500/10"
                      : "text-[var(--text-muted)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)]"
                  )}
                >
                  {copied ? (
                    <>
                      <Check className="w-3.5 h-3.5" />
                      Copied!
                    </>
                  ) : (
                    <>
                      <Copy className="w-3.5 h-3.5" />
                      Copy
                    </>
                  )}
                </button>
              )}
            </div>
            {hasChanges ? (
              <CodeBlock code={alterStatements.join(";\n") + ";"} language="sql" />
            ) : (
              <div className="p-4 rounded-lg bg-[var(--bg-secondary)] border border-[var(--border-color)] text-center">
                <p className="text-sm text-[var(--text-muted)]">
                  No changes detected. Modify columns above to generate ALTER statements.
                </p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

/**
 * Migration Result Panel - shows per-statement results from dry run / apply
 */
function MigrationResultPanel({ result }: { result: MigrationResult }) {
  return (
    <div
      className={cn(
        "rounded-lg border overflow-hidden",
        result.ok
          ? "border-green-500/30 bg-green-500/5"
          : "border-red-500/30 bg-red-500/5"
      )}
    >
      {/* Header */}
      <div className={cn(
        "flex items-center justify-between px-3 py-2",
        result.ok ? "bg-green-500/10" : "bg-red-500/10"
      )}>
        <div className="flex items-center gap-2">
          {result.ok ? (
            <CheckCircle2 className="w-4 h-4 text-green-400" />
          ) : (
            <XCircle className="w-4 h-4 text-red-400" />
          )}
          <span className={cn(
            "text-sm font-medium",
            result.ok ? "text-green-400" : "text-red-400"
          )}>
            {result.dry_run ? "Dry Run" : "Migration"}{" "}
            {result.ok ? "Passed" : "Failed"}
          </span>
        </div>
        <div className="flex items-center gap-3 text-xs text-[var(--text-muted)]">
          <span>{result.duration_ms.toFixed(1)}ms</span>
          {result.committed && (
            <span className="text-green-400 font-medium">Committed</span>
          )}
          {result.dry_run && (
            <span className="text-blue-400 font-medium">Not persisted</span>
          )}
        </div>
      </div>

      {/* Statement Results */}
      <div className="divide-y divide-[var(--border-color)]">
        {result.statements.map((stmt, i) => (
          <div key={i} className="px-3 py-2">
            <div className="flex items-start gap-2">
              {result.statements.length > 1 && (
                stmt.ok ? (
                  <CheckCircle2 className="w-3.5 h-3.5 text-green-400 mt-0.5 shrink-0" />
                ) : (
                  <XCircle className="w-3.5 h-3.5 text-red-400 mt-0.5 shrink-0" />
                )
              )}
              <div className="flex-1 min-w-0">
                <pre className="text-xs font-mono text-[var(--text-secondary)] whitespace-pre-wrap break-all">
                  {stmt.sql}
                </pre>
                <div className="flex items-center gap-3 mt-1 text-xs text-[var(--text-muted)]">
                  <span>{stmt.duration_ms.toFixed(1)}ms</span>
                  {stmt.rows_affected != null && (
                    <span>{stmt.rows_affected} rows affected</span>
                  )}
                </div>
                {stmt.error && (
                  <div className="mt-1.5 p-2 rounded bg-red-500/10 text-xs">
                    <p className="text-red-400 font-medium">
                      {stmt.error.code && (
                        <span className="font-mono mr-1.5">[{stmt.error.code}]</span>
                      )}
                      {stmt.error.message}
                    </p>
                    {stmt.error.detail && (
                      <p className="text-red-400/80 mt-0.5">{stmt.error.detail}</p>
                    )}
                    {stmt.error.hint && (
                      <p className="text-yellow-400/80 mt-0.5">Hint: {stmt.error.hint}</p>
                    )}
                  </div>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

/**
 * Renders content based on the active tab
 */
export function TabContent() {
  const tabs = useUIStore((state) => state.tabs);
  const activeTabId = useUIStore((state) => state.activeTabId);
  const connectionStatus = useProjectStore((state) => state.connectionStatus);

  if (connectionStatus !== "connected" || tabs.length === 0) {
    return null;
  }

  return (
    <>
      {tabs.map((tab) => {
        const isActive = tab.id === activeTabId;

        let content: React.ReactNode = null;
        if (tab.type === "table" && tab.schema && tab.table) {
          content = (
            <TableTabContent
              key={`${tab.schema}.${tab.table}`}
              schema={tab.schema}
              table={tab.table}
            />
          );
        } else if (tab.type === "create-table") {
          content = <CreateTableTabContent key={tab.id} tab={tab} />;
        } else if (tab.type === "edit-table" && tab.schema && tab.table) {
          content = <EditTableTabContent key={tab.id} tab={tab} />;
        } else if (tab.type === "import-data" && tab.schema && tab.table) {
          content = <ImportDataTab key={tab.id} tab={tab} />;
        } else if (tab.type === "query") {
          content = <QueryTab key={tab.id} tab={tab} />;
        }

        if (!content) return null;

        return (
          <div
            key={tab.id}
            className="h-full"
            style={{ display: isActive ? "contents" : "none" }}
          >
            {content}
          </div>
        );
      })}
    </>
  );
}
