import { useState, useEffect, useMemo } from "react";
import { X, Save, Clock, Trash2, Plus } from "lucide-react";
import { cn } from "../../lib/utils";
import { TypedInput } from "../ui/TypedInput";
import type { Column, Row, CellValue } from "../../types";

interface RowDetailModalProps {
  row?: Row;
  rowIndex?: number;
  columns: Column[];
  isOpen: boolean;
  onClose: () => void;
  onSave: (data: Row) => void;      // Direct save (instant commit)
  onStage: (data: Row) => void;     // Add to staged changes
  onDelete?: () => void;            // Delete row (not used in create mode)
  readOnly?: boolean;
  isDeleted?: boolean;
  mode?: "edit" | "create";
  error?: string | null;            // Error message to display
  onClearError?: () => void;        // Clear error when user makes changes
}

/**
 * Format cell value for display/editing
 */
function formatValue(value: CellValue | undefined): string {
  if (value === null || value === undefined) return "";
  if (typeof value === "boolean") return value ? "true" : "false";
  if (typeof value === "object") return JSON.stringify(value, null, 2);
  return String(value);
}

/**
 * Parse string value back to appropriate type
 */
function parseValue(value: string, dataType: string): CellValue {
  if (value === "" || value.toLowerCase() === "null") return null;

  const type = dataType.toLowerCase();
  if (type.includes("int")) {
    const num = parseInt(value, 10);
    return isNaN(num) ? value : num;
  }
  if (type.includes("float") || type.includes("double") || type.includes("numeric") || type.includes("decimal")) {
    const num = parseFloat(value);
    return isNaN(num) ? value : num;
  }
  if (type.includes("bool")) {
    return value.toLowerCase() === "true";
  }
  if (type.includes("json")) {
    try {
      return JSON.parse(value);
    } catch {
      return value;
    }
  }
  return value;
}

/**
 * Check if a column is auto-generated (serial, identity, etc.)
 */
function isAutoGeneratedColumn(column: Column): boolean {
  const type = column.dataType.toLowerCase();
  const defaultVal = column.defaultValue ?? "";
  // Auto-generated if:
  // - Serial types (serial, bigserial, smallserial)
  // - Has a function call as default (contains parentheses): nextval(), uuid_generate_v7(), gen_random_uuid(), now(), etc.
  return type.includes("serial") || /\w+\s*\(/.test(defaultVal);
}

export function RowDetailModal({
  row,
  rowIndex,
  columns,
  isOpen,
  onClose,
  onSave,
  onStage,
  onDelete,
  readOnly = false,
  isDeleted = false,
  mode = "edit",
  error = null,
  onClearError,
}: RowDetailModalProps) {
  const [editedValues, setEditedValues] = useState<Record<string, string>>({});
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({});

  const isCreateMode = mode === "create";

  // Initialize edited values when modal opens
  useEffect(() => {
    if (isOpen) {
      const initial: Record<string, string> = {};
      columns.forEach((col) => {
        if (isCreateMode) {
          // For create mode: use default value if available, otherwise empty
          if (isAutoGeneratedColumn(col)) {
            initial[col.name] = ""; // Auto-generated fields stay empty
          } else if (col.defaultValue != null && !col.defaultValue.includes("nextval")) {
            // Use default value, but clean it up (remove type casts like ::text)
            let defaultVal = col.defaultValue;
            // Remove PostgreSQL type casts (e.g., 'value'::text -> value)
            if (defaultVal.includes("::")) {
              defaultVal = defaultVal.split("::")[0];
            }
            // Remove surrounding quotes
            if (defaultVal.startsWith("'") && defaultVal.endsWith("'")) {
              defaultVal = defaultVal.slice(1, -1);
            }
            initial[col.name] = defaultVal;
          } else {
            initial[col.name] = "";
          }
        } else {
          // For edit mode: use existing row values
          initial[col.name] = formatValue(row?.[col.name]);
        }
      });
      setEditedValues(initial);
      setShowDeleteConfirm(false);
      setValidationErrors({});
    }
  }, [isOpen, row, columns, isCreateMode]);

  // Validate required fields - returns errors object
  const validateFields = (): Record<string, string> => {
    const errors: Record<string, string> = {};
    columns.forEach((col) => {
      // Skip nullable fields - they can be empty
      if (col.isNullable) return;

      // In create mode, skip auto-generated columns (they'll be filled by DB)
      if (isCreateMode && isAutoGeneratedColumn(col)) return;

      // Skip columns with default values in create mode
      if (isCreateMode && col.defaultValue != null) return;

      const value = editedValues[col.name] ?? "";
      const trimmed = value.trim();

      // Empty or "null" string means null value
      if (trimmed === "" || trimmed.toLowerCase() === "null") {
        errors[col.name] = "This field is required";
      }
    });
    return errors;
  };

  // Check if any values have changed (always true in create mode)
  const hasChanges = useMemo(() => {
    if (isCreateMode) return true;
    return columns.some((col) => {
      const original = formatValue(row?.[col.name]);
      const edited = editedValues[col.name] ?? "";
      return original !== edited;
    });
  }, [columns, row, editedValues, isCreateMode]);

  // Build the updated row data
  const getUpdatedRow = (): Row => {
    const updated: Row = {};
    columns.forEach((col) => {
      const editedValue = editedValues[col.name] ?? "";
      updated[col.name] = parseValue(editedValue, col.dataType);
    });
    return updated;
  };

  const handleSave = () => {
    const errors = validateFields();
    if (Object.keys(errors).length > 0) {
      setValidationErrors(errors);
      return;
    }
    if (hasChanges) {
      onSave(getUpdatedRow());
      // In create mode, parent controls closing based on success/failure
      // In edit mode, close immediately (legacy behavior)
      if (!isCreateMode) {
        onClose();
      }
    } else {
      onClose();
    }
  };

  const handleStage = () => {
    const errors = validateFields();
    if (Object.keys(errors).length > 0) {
      setValidationErrors(errors);
      return;
    }
    if (hasChanges) {
      onStage(getUpdatedRow());
    }
    onClose();
  };

  const handleDelete = () => {
    if (showDeleteConfirm) {
      onDelete?.();
      onClose();
    } else {
      setShowDeleteConfirm(true);
    }
  };

  const handleFieldChange = (columnName: string, value: string) => {
    setEditedValues((prev) => ({
      ...prev,
      [columnName]: value,
    }));
    // Clear validation error when user modifies the field
    if (validationErrors[columnName]) {
      setValidationErrors((prev) => {
        const next = { ...prev };
        delete next[columnName];
        return next;
      });
    }
    // Clear external error when user makes changes
    onClearError?.();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
      <div
        className={cn(
          "w-[700px] max-w-[90vw] max-h-[85vh] flex flex-col",
          "bg-[var(--bg-primary)] border border-[var(--border-color)] rounded-lg shadow-xl"
        )}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-4 py-3 border-b border-[var(--border-color)] shrink-0">
          <div className="flex items-center gap-3">
            {isCreateMode ? (
              <div className="flex items-center gap-2">
                <Plus className="w-4 h-4 text-purple-400" />
                <span className="text-sm font-medium text-[var(--text-primary)]">
                  Add New Row
                </span>
              </div>
            ) : (
              <span className="text-sm font-medium text-[var(--text-primary)]">
                Row #{(rowIndex ?? 0) + 1}
              </span>
            )}
            {isDeleted && (
              <span className="px-2 py-0.5 text-xs rounded bg-red-500/20 text-red-400">
                Marked for deletion
              </span>
            )}
            {hasChanges && !isDeleted && !isCreateMode && (
              <span className="px-2 py-0.5 text-xs rounded bg-[var(--warning)]/20 text-[var(--warning)]">
                Modified
              </span>
            )}
          </div>
          <button
            onClick={onClose}
            className="p-1.5 rounded-md text-[var(--text-muted)] hover:text-[var(--text-primary)] hover:bg-[var(--bg-tertiary)] transition-colors"
          >
            <X className="w-4 h-4" />
          </button>
        </div>

        {/* Form content */}
        <div className="flex-1 overflow-y-auto p-4 min-h-0">
          <div className="space-y-4">
            {columns.map((column) => {
              const value = editedValues[column.name] ?? "";
              const originalValue = formatValue(row?.[column.name]);
              const isModified = !isCreateMode && value !== originalValue;
              const hasError = !!validationErrors[column.name];
              const isAutoGenerated = isCreateMode && isAutoGeneratedColumn(column);
              const hasDefault = isCreateMode && column.defaultValue != null && !isAutoGenerated;
              // Required only if: not nullable, not auto-generated, and no default value
              const isRequired = !column.isNullable && !isAutoGenerated && !hasDefault;

              // Determine placeholder
              let placeholder = column.isNullable ? "NULL" : "Required";
              if (isAutoGenerated) {
                placeholder = "Auto-generated";
              } else if (hasDefault && !value) {
                placeholder = `Default: ${column.defaultValue}`;
              }

              return (
                <div key={column.name} className="space-y-1.5">
                  <div className="flex items-center gap-2">
                    <label className="text-xs font-medium text-[var(--text-primary)]">
                      {column.name}
                    </label>
                    <span className="text-[10px] text-[var(--text-muted)]">
                      {column.dataType}
                    </span>
                    {column.isPrimaryKey && (
                      <span className="px-1.5 py-0.5 text-[10px] rounded bg-[var(--warning)]/20 text-[var(--warning)]">
                        PK
                      </span>
                    )}
                    {isAutoGenerated && (
                      <span className="px-1.5 py-0.5 text-[10px] rounded bg-[var(--accent)]/20 text-[var(--accent)]">
                        auto
                      </span>
                    )}
                    {column.isForeignKey && (
                      <span className="px-1.5 py-0.5 text-[10px] rounded bg-purple-500/20 text-purple-400">
                        FK
                      </span>
                    )}
                    {isRequired && (
                      <span className="text-[10px] text-red-400">*</span>
                    )}
                    {isModified && (
                      <span className="w-1.5 h-1.5 rounded-full bg-[var(--warning)]" title="Modified" />
                    )}
                  </div>
                  <TypedInput
                    value={value}
                    onChange={(newValue) => handleFieldChange(column.name, newValue)}
                    dataType={column.dataType}
                    disabled={readOnly || isDeleted || isAutoGenerated}
                    placeholder={placeholder}
                    hasError={hasError}
                    isModified={isModified}
                    isForeignKey={column.isForeignKey}
                    foreignKeyInfo={column.foreignKeyInfo}
                  />
                  {hasError && (
                    <p className="text-xs text-red-400">{validationErrors[column.name]}</p>
                  )}
                </div>
              );
            })}
          </div>
        </div>

        {/* Error display */}
        {error && (
          <div className="px-4 py-3 border-t border-red-500/30 bg-red-500/10 shrink-0">
            <div className="flex items-start gap-2">
              <svg
                className="w-4 h-4 text-red-400 mt-0.5 shrink-0"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
              <div className="flex-1 min-w-0">
                <p className="text-sm font-medium text-red-400">Failed to save</p>
                <p className="text-xs text-red-400/80 mt-0.5 break-words">{error}</p>
              </div>
            </div>
          </div>
        )}

        {/* Footer */}
        <div className="flex items-center justify-between px-4 py-3 border-t border-[var(--border-color)] shrink-0">
          <div>
            {!readOnly && !isDeleted && !isCreateMode && onDelete && (
              <button
                onClick={handleDelete}
                className={cn(
                  "flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-md transition-colors",
                  showDeleteConfirm
                    ? "bg-red-500 text-white"
                    : "text-red-400 hover:bg-red-500/10"
                )}
              >
                <Trash2 className="w-3.5 h-3.5" />
                {showDeleteConfirm ? "Click to confirm" : "Delete"}
              </button>
            )}
          </div>

          <div className="flex items-center gap-2">
            <button
              onClick={onClose}
              className={cn(
                "px-3 py-1.5 text-sm rounded-md",
                "text-[var(--text-secondary)] hover:text-[var(--text-primary)]",
                "hover:bg-[var(--bg-tertiary)] transition-colors"
              )}
            >
              Cancel
            </button>
            {!readOnly && !isDeleted && (
              <>
                <button
                  onClick={handleStage}
                  disabled={!hasChanges}
                  className={cn(
                    "flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-md",
                    "text-[var(--text-secondary)] border border-[var(--border-color)]",
                    "hover:bg-[var(--bg-tertiary)] transition-colors",
                    "disabled:opacity-50 disabled:cursor-not-allowed"
                  )}
                >
                  <Clock className="w-3.5 h-3.5" />
                  Stage
                </button>
                <button
                  onClick={handleSave}
                  disabled={!hasChanges}
                  className={cn(
                    "flex items-center gap-1.5 px-3 py-1.5 text-sm rounded-md",
                    isCreateMode ? "bg-purple-500 text-white" : "bg-[var(--accent)] text-white",
                    "hover:opacity-90 transition-opacity",
                    "disabled:opacity-50 disabled:cursor-not-allowed"
                  )}
                >
                  {isCreateMode ? (
                    <>
                      <Plus className="w-3.5 h-3.5" />
                      Insert
                    </>
                  ) : (
                    <>
                      <Save className="w-3.5 h-3.5" />
                      Save
                    </>
                  )}
                </button>
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
